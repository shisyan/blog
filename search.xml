<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Git介绍</title>
    <url>/2021/10/09/Git%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<p>Git 是目前世界上被最广泛使用的现代软件版本管理系统。Git 本身亦是一个成熟并处于活跃开发状态的开源项目，它最初是由 Linux 操作系统内核的创造者 Linus Torvalds 在 2005 年创造。今天惊人数量的软件项目依赖 Git 进行版本管理，这些项目包括开源以及各种商业软件。Git 在职业软件开发者中拥有良好的声誉，Git 目前支持绝大多数的操作系统以及 IDE（Integrated Development Environments）。</p>
<a id="more"></a>
<p>Git 使用分散式架构，是分散式版本管理 DVCS（Distributed Version Control System）的代表。相较于例如 CVS 或者 Subversion 等集中式版本管理软件，Git 并不是将代码的所有修改历史保存在中心服务器中。在 Git 中取而代之的是，所有参与项目的开发者都拥有各自的代码完全拷贝，并在自己的拷贝上进行软件开发。</p>
<p>除了分散式的特点之外，Git 的设计也针对性能，安全性和柔软性作了特别优化。</p>
<h1 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h1><p>Git 的底层性能相较于其他版本管理软件有强大的优势。在 Git 中所有的操作包括提交修改，创建分支，融合分支，以及求取差分都经过了性能优化。这些优化来自于 Git 的开发者对实际一般代码开发模式的深度认识和广泛知识。</p>
<p>不同于某些版本管理软件，Git 在决定代码修改历史以及保存形式的时候不会被文件名的变化所愚弄，Git 关注的是文件的内容本身。在实际操作中，代码文件经历频繁的再命名，分解和合并。Git 使用一种混合了差分编码（delta encoding，仅保存代码修改的差分），压缩，直接保存，以及版本元数据（version metadata objects）的管理方式。</p>
<p>分散式的架构也给 Git 带来了极大的性能优势。</p>
<p>比如说，现有一名开发成员 Alice 对代码进行了一些改动，添加了一些在2.0版本中准备公开的功能，然后将这些修改以及一份简单的说明进行了提交。随后她又增加了一些另外的新功能，并又作了一次新提交。显然这两次修改在版本历史中被分开各自进行了保存。在这之后 Alice 把代码切换到了 1.3 版本，修复了一些旧版本中的 Bug（这和她新添加的功能没有关系）。这次修复的目的是为了让团队可以在公开 2.0 版本之前，释放一个 1.3.1 版本来解决 1.3 版本中的 Bug 问题。Alice 马上又可以回到她之前进行的 2.0 版本功能开发之中（通过切换代码分支），这些操作由于 Git 的分散属性，都不需要通过网络来连接到中央服务器进行，她甚至可以在飞机中完成这一切。当她完成所有工作，只需要向远程的代码库推送（Push）自己的修改即可。</p>
<h1 id="安全性"><a href="#安全性" class="headerlink" title="安全性"></a>安全性</h1><p>Git 将保持所管理代码的整合性作为首要要务。所有的文件内容，文件相互关系，以及文件目录结构，版本，标签以及修改，都经过加密哈希校验算法（SHA1）的保护。这可以防止各种意外的代码修改失误，或者是第三者的恶意修改，使得代码修改历史完全可追迹。</p>
<p>使用 Git 你可以确信你拥有代码的完整修改历史。</p>
<p>某些其他的版本管理软件对发布后的代码不进行任何保护。这对于完全依赖于软件开发的团队来说可以是一种非常严重的安全脆弱性问题。</p>
<h1 id="柔软性"><a href="#柔软性" class="headerlink" title="柔软性"></a>柔软性</h1><p>Git 的关键设计目标之一就是保持柔软性。Git 在以下方面都展现出了其柔软性：支持各种非线性的开发工作流程，对或大或小的软件项目都可以良好支持，以及兼容各种操作系统和协议。</p>
<p>Git 支持将分支和标签作为一级基本对象（不同于 SVN），所以所有对分支和标签的操作也都会被保存到修改历史中。并不是所有的版本管理软件支持这一层面的追迹。</p>
<h1 id="使用-Git-进行版本管理"><a href="#使用-Git-进行版本管理" class="headerlink" title="使用 Git 进行版本管理"></a>使用 Git 进行版本管理</h1><p>Git 对今天绝大多数软件开发团队来说都是最佳的选择。虽然每个团队都有各自的特点和目标，但是这里我们依然可以列举一些对他们来说Git优于其他选择的理由：</p>
<h2 id="Git-很棒"><a href="#Git-很棒" class="headerlink" title="Git 很棒"></a>Git 很棒</h2><p>Git 兼备了功能性，高性能，安全性和柔软性，这些是很多软件开发团队以及个人所需要的要素。我们已经在上面详细讨论了这些特性。对很多软件开发团队来说，以以上标准货比三家的最终结果都是选择Git。</p>
<h2 id="Git-已经成为了默认的行业标准"><a href="#Git-已经成为了默认的行业标准" class="headerlink" title="Git 已经成为了默认的行业标准"></a>Git 已经成为了默认的行业标准</h2><p>Git 是受到最广泛使用和支持的版本管理软件。这使得 Git 在以下这些方面具有极大的吸引力。我们在 Atlassian（此 Tutorial 作者所处的公司）的大多数代码都是用 Git 来进行管理的。</p>
<p>绝大多数的软件开发者都有过 Git 的使用经历，很大一部分在校或者刚刚毕业的学生甚至只用过 Git 进行版本管理。虽然在一些公司开发成员可能在从其他版本管理软件迁移到 Git 的过程中要经历比较陡峭的学习曲线，但是大多数开发者以及他们未来的潜在开发者（学生）都已经具备了使用 Git 的基本技能，这就意味着他们不再需要额外的培训。</p>
<p>Git 的普及还带来很多其他的好处，Git 的市场占有率意味着很多第三方的服务和 IDE 都开始默认支持 Git。比如我们的 DVCS 客户端 Source Tree，项目开发管理软件 JIRA，以及代码托管服务 Bitbucket。</p>
<p>如果你是一个开发新手并期待在未来构建自己的专业开发技能，Git 毫无疑问是你在版本管理上的第一选择。</p>
<h2 id="Git-是一个高质量的开源项目"><a href="#Git-是一个高质量的开源项目" class="headerlink" title="Git 是一个高质量的开源项目"></a>Git 是一个高质量的开源项目</h2><p>Git 本身是一个拥有良好支持和管理的开源软件项目。Git 的开发者在过去的十年中展现了良好的公平性，成熟的开发手段以保障其用户将来的需求，以及定期的更新以保持其可用性和功能性。开源的特性使得项目代码本身受到无微不至的检查，现在有无数的企业都依赖于 Git 的超高软件开发质量。</p>
<p>Git 同时享有极好的社区支持和庞大的用户群体。你可以找到各种内容深入浅出的学习资料，包括书籍，教程，以及专题网站。甚至还有广播以及视频教程存在。</p>
<p>保持开源降低了编程爱好者的投入成本因为他们不需要花一分钱来使用 Git。在开源项目中，Git 无疑扮演了前一世代版本管理软件，比如 SVN 和 CVS，的成功接班人。</p>
<h2 id="对于-Git-的批评意见"><a href="#对于-Git-的批评意见" class="headerlink" title="对于 Git 的批评意见"></a>对于 Git 的批评意见</h2><p>对于 Git 的一个常见批评是它非常难以掌握。Git 中的某些术语对刚上手的朋友或者是使用其他系统的朋友可能会比较陌生，比如说，revert 这个命令在 Git 中和在 SVN 或者 CVS 中具有不同的含义。不过尽管如此，Git 依然向用户提供了非常强大的功能。学习掌握这些功能也许会花一些时间，但是一旦你学会了这些技能，它们会帮助你大大提高团队的开发效率。</p>
<p>对于曾经使用非分散式版本管理的团队来说，保存代码的中央服务器可能是他们所不想舍去的。不过，虽然 Git 的确是分散式的架构设计，但是你依然可以设立一个「官方」的代码库来强制保存所有的修改。使用 Git 时，由于所有的开发者都拥有完整的代码库拷贝，所以他们的工作不会被中央服务器的性能甚至有无左右。即便他们下线或者在外，他们依然可以随时查看代码库的修改历史。得益于 Git 的分散式特性，你可以保持自己原有的工作方式但得到 Git 带来的额外好处，有时候你甚至会发现自己不曾意识到有些事居然还可以这样干。</p>
]]></content>
      <categories>
        <category>Git</category>
      </categories>
  </entry>
  <entry>
    <title>Java8新特性</title>
    <url>/2020/10/27/Java8%E6%96%B0%E7%89%B9%E6%80%A7/</url>
    <content><![CDATA[<p>毫无疑问，Java 8是自Java  5（2004年）发布以来Java语言最大的一次版本升级，Java 8带来了很多的新特性，比如编译器、类库、开发工具和JVM（Java虚拟机）。在这篇教程中我们将会学习这些新特性，并通过真实例子演示说明它们适用的场景。</p>
<a id="more"></a>

<h1 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h1><p>在JDK8之前，一个方法能接受的参数都是变量，例如： object.method(Object o)<br>那么，如果需要传入一个动作呢？比如回调。<br>那么你可能会想到匿名内部类。<br>例如：<br>匿名内部类是需要依赖接口的，所以需要先定义个接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">PersonCallback</span> </span>&#123;</span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">callback</span><span class="params">(Person person)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Person类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(<span class="keyword">int</span> id, String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 创建一个person后，进行回调</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">create</span><span class="params">(Integer id, String name, PersonCallback personCallback)</span> </span>&#123;</span><br><span class="line">        Person person = <span class="keyword">new</span> Person(id, name);</span><br><span class="line">        personCallback.callback(person);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Person.create(<span class="number">1</span>, <span class="string">&quot;张三&quot;</span>, <span class="keyword">new</span> PersonCallback() &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">callback</span><span class="params">(Person person)</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;去注册...&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    Person.create(<span class="number">2</span>, <span class="string">&quot;老师&quot;</span>, <span class="keyword">new</span> PersonCallback() &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">callback</span><span class="params">(Person person)</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;去登陆...&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>上面的PersonCallback其实就是一种动作，但是我们真正关心的只有callback方法里的内容而已，我们用Lambda<br>表示，可以将上面的代码就可以优化成：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Person.create(<span class="number">1</span>, <span class="string">&quot;张三&quot;</span>, (Person person) -&gt; &#123;System.out.println(<span class="string">&quot;去登陆...&quot;</span>);&#125;)</span><br></pre></td></tr></table></figure>
<p>有没有发现特别简单了…，但是我们发现Person.create这个方法其实接收的对象依然是PersonCallback这个接<br>口，但是现在传的是一个Lambda表达式，那么难道Lambda表达式也实现了这个接口？问题也放这，我们<br>先看一下Lambda表达式的接口。<br>Lambda允许把函数作为一个方法的参数，一个lambda由用逗号分隔的<code>参数列表</code>、<code>–&gt;</code>、<code>函数体</code>三部分表<br>示。对于上面的表达式</p>
<ol>
<li><code>(Person person)</code>为Lambda表达式的入参，<code>&#123;System.out.println(&quot;去注册...&quot;);&#125;</code>为函数体</li>
<li>重点是这个表达式是没有名字的。</li>
</ol>
<p>我们知道，当我们实现一个接口的时候，肯定要实现接口里面的方法，那么现在一个Lambda表达式应该也要遵<br>循这一个基本准则，那么一个Lambda表达式它实现了接口里的什么方法呢？<br>答案是：一个Lambda表达式实现了接口里的有且仅有的唯一一个抽象方法。那么对于这种接口就叫做<strong>函数式接口</strong>。<br>Lambda表达式其实完成了<strong>实现接口并且实现接口里的方法</strong>这一功能，也可以认为Lambda表达式代表一种<strong>动作</strong>，我们可以直接把这种特殊的动作进行传递。<br>当然，对于上面的Lambda表达式你可以简化：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Person.create(<span class="number">1</span>, <span class="string">&quot;张三&quot;</span>, person -&gt; System.out.println(<span class="string">&quot;去登陆...&quot;</span>));</span><br></pre></td></tr></table></figure>
<p>这归功于Java8的类型推导机制。因为现在接口里只有一个方法，那么现在这个Lambda表达式肯定是对应实现了这个方法，既然是唯一的对应关系，那么入参肯定是Person类，所以可以简写，并且方法体只有唯一的一条语句，所以也可以简写，以达到表达式简洁的效果。</p>
<h1 id="函数式接口"><a href="#函数式接口" class="headerlink" title="函数式接口"></a>函数式接口</h1><p>函数式接口是新增的一种接口定义。</p>
<p>用<code>@FunctionalInterface</code>修饰的接口叫做函数式接口，或者，函数式接口就是一个<strong>只具有一个抽象方法的普通接口</strong>，<code>@FunctionalInterface</code>可以起到校验的作用。<br>下面的接口只有一个抽象方法能编译正确：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TestFunctionalInterface</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面的接口有多个抽象方法会编译错误：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TestFunctionalInterface</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在JDK7中其实就已经有一些函数式接口了，比如Runnable、Callable、FileFilter等等。<br>在JDK8中也增加了很多函数式接口，比如java.util.function包。<br>比如这四个常用的接口：</p>
<table>
<thead>
<tr>
<th>接口</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>Supplier</td>
<td>无参数，返回一个结果</td>
</tr>
<tr>
<td>Function</td>
<td>接受一个输入参数，返回一个结果</td>
</tr>
<tr>
<td>Consumer</td>
<td>接受一个输入参数，无返回结果</td>
</tr>
<tr>
<td>Predicate</td>
<td>接受一个输入参数，返回一个布尔值结果</td>
</tr>
</tbody></table>
<p>那么Java8中给我们加了这么多函数式接口有什么作用？<br>上文我们分析到，一个Lambda表达式其实也可以理解为一个函数式接口的实现者，但是作为表达式，它的写法<br>其实是多种多样的，比如</p>
<ul>
<li>() -&gt; {return 0;}，没有传入参数，有返回值</li>
<li>(int i) -&gt; {return 0;}，传入一个参数，有返回值</li>
<li>(int i) -&gt; {System.out.println(i)}，传入一个int类型的参数，但是没有返回值</li>
<li>(int i, int j) -&gt; {System.out.println(i)}，传入两个int类型的参数，但是没有返回值</li>
<li>(int i, int j) -&gt; {return i+j;}，传入两个int类型的参数，返回一个int值</li>
<li>(int i, int j) -&gt; {return i&gt;j;}，传入两个int类型的参数，返回一个boolean值</li>
</ul>
<p>还有许多许多种情况,那么这每种表达式的写法其实都应该是某个函数式接口的实现类，需要特定<br>函数式接口进行对应，比如上面的四种情况就分别对应<code>Supplier&lt;T&gt;</code>，<code>Function&lt;T,R&gt;</code>， <code>Consumer&lt;T&gt;</code>，<code>BiConsumer&lt;T,U&gt;</code>，<code>BiFunction&lt;T,U,R&gt;</code>，<code>BiPredicate&lt;T,U&gt;</code>。</p>
<p>答案已经明显了，Java8中提供给我们这么多函数式接口就是为了让我们写Lambda表达式更加方便，当然遇到特殊情况，你还是需要定义你自己的函数式接口然后才能写对应的Lambda表达式。</p>
<p>总的来说，如果没有函数式接口，就不能写Lambda表达式。</p>
<h1 id="接口的默认方法与静态方法"><a href="#接口的默认方法与静态方法" class="headerlink" title="接口的默认方法与静态方法"></a>接口的默认方法与静态方法</h1><p>在JDK7中，如果想对接口Collection新增一个方法，那么你需要修改它所有的实现类源码（这是非常恐怖的），在那么Java8之前是怎么设计来解决这个问题的呢，用的是抽象类，比如：</p>
<p>现在有一个接口PersonInterface接口，里面有1个抽象方法:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">PersonInterface</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">getName</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有三个实现类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">YellowPerson</span> <span class="keyword">implements</span> <span class="title">PersonInterface</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;yellow&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WhitePerson</span> <span class="keyword">implements</span> <span class="title">PersonInterface</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;white&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BlackPerson</span> <span class="keyword">implements</span> <span class="title">PersonInterface</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;black&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在我需要在PersonInterface接口中新增一个方法，那么势必它的三个实现类都需要做相应改动才能编译通过，这里我就不进行演示了，那么我们在最开始设计的时候，其实可以增加一个抽象类PersonAbstract，三个实现类改为继承这个抽象类，按照这种设计方法，对PersonInterface接口中新增一个方法是，其实只需要改动PersonAbstract类去实现新增的方法就好了，其他实现类不需要改动了：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">PersonInterface</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">getName</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">walk</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonAbstract</span> <span class="keyword">implements</span> <span class="title">PersonInterface</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">walk</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;walk&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BlackPerson</span> <span class="keyword">extends</span> <span class="title">PersonAbstract</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;black&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WhitePerson</span> <span class="keyword">extends</span> <span class="title">PersonAbstract</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;white&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">YellowPerson</span> <span class="keyword">extends</span> <span class="title">PersonAbstract</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;yellow&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么在Java8中支持直接在接口中添加已经实现了的方法，一种是Default方法（默认方法），一种是Static方法（静态方法）。</p>
<h1 id="接口的默认方法"><a href="#接口的默认方法" class="headerlink" title="接口的默认方法"></a>接口的默认方法</h1><p>在接口中用default修饰的方法称为默认方法 默认方法。<br>接口中的默认方法一定要有默认实现（方法体），接口实现者可以继承它，也可以覆盖它。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">testDefault</span><span class="params">()</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;default&quot;</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="接口的静态方法"><a href="#接口的静态方法" class="headerlink" title="接口的静态方法"></a>接口的静态方法</h1><p>在接口中用static修饰的方法称为静态方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testStatic</span><span class="params">()</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;static&quot;</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>调用方式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">TestInterface.testStatic();</span><br></pre></td></tr></table></figure>
<p>因为有了默认方法和静态方法，所以你不用去修改它的实现类了，可以进行直接调用。</p>
<h1 id="方法的引用"><a href="#方法的引用" class="headerlink" title="方法的引用"></a>方法的引用</h1><p>有个函数式接口Consumer，里面有个抽象方法accept能够接收一个参数但是没有返回值，这个时候我想实现accept方法，让它的功能为打印接收到的那个参数，那么我可以使用Lambda表达式这么做：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Consumer&lt;String&gt; consumer = s -&gt; System.out.println(s);</span><br><span class="line">consumer.accept(<span class="string">&quot;张三&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>但是其实我想要的这个功能PrintStream类（也就是System.out的类型）的println方法已经实现了，这一步还可以再简单点，如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Consumer&lt;String&gt; consumer = System.out::println;</span><br><span class="line">consumer.accept(<span class="string">&quot;张三&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>这就是方法引用，方法引用方法的参数列表必须与函数式接口的抽象方法的参数列表保持一致，返回值不作要求。</p>
<h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><h3 id="引用方法"><a href="#引用方法" class="headerlink" title="引用方法"></a>引用方法</h3><h4 id="实例对象-实例方法名"><a href="#实例对象-实例方法名" class="headerlink" title="实例对象::实例方法名"></a>实例对象::实例方法名</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Consumer&lt;String&gt; consumer = s -&gt; System.out.println(s);</span></span><br><span class="line">Consumer&lt;String&gt; consumer = System.out::println;</span><br><span class="line">consumer.accept(<span class="string">&quot;张三&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>System.out代表的就是PrintStream类型的一个实例，println是这个实例的一个方法。</p>
<h4 id="类名-实例方法名"><a href="#类名-实例方法名" class="headerlink" title="类名::实例方法名"></a>类名::实例方法名</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Function&lt;Long, Long&gt; f = x -&gt; Math.abs(x);</span></span><br><span class="line">Function&lt;Long, Long&gt; f = Math::abs;</span><br><span class="line">Long result = f.apply(-<span class="number">3L</span>);</span><br></pre></td></tr></table></figure>
<p>Math是一个类而abs为该类的静态方法。Function中的唯一抽象方法apply方法参数列表与abs方法的参数列表相同，都是接收一个Long类型参数。</p>
<h4 id="类名-静态方法名"><a href="#类名-静态方法名" class="headerlink" title="类名::静态方法名"></a>类名::静态方法名</h4><p>若Lambda表达式的参数列表的第一个参数，是实例方法的调用者，第二个参数(或无参)是实例方法的参数时，就可以使用这种方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//BiPredicate&lt;String, String&gt; b = (x,y) -&gt; x.equals(y);</span></span><br><span class="line">BiPredicate&lt;String, String&gt; b = String::equals;</span><br><span class="line">b.test(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>String是一个类而equals为该类的定义的实例方法。BiPredicate中的唯一抽象方法test方法参数列表与equals方法<br>的参数列表相同，都是接收两个String类型参数。</p>
<h3 id="引用构造方法"><a href="#引用构造方法" class="headerlink" title="引用构造方法"></a>引用构造方法</h3><p>在引用构造器的时候，构造器参数列表要与接口中抽象方法的参数列表一致,格式为 类名::new。如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Function&lt;Integer, StringBuffer&gt; fun = n -&gt; new StringBuffer(n);</span></span><br><span class="line">Function&lt;Integer, StringBuffer&gt; fun = StringBuffer::<span class="keyword">new</span>;</span><br><span class="line">StringBuffer buffer = fun.apply(<span class="number">10</span>);</span><br></pre></td></tr></table></figure>
<p>Function接口的apply方法接收一个参数，并且有返回值。在这里接收的参数是Integer类型，与StringBuffer类的一个构造方法StringBuffer(int capacity)对应，而返回值就是StringBuffer类型。上面这段代码的功能就是创建一个Function实例，并把它apply方法实现为创建一个指定初始大小的StringBuffer对象。</p>
<h3 id="引用数组"><a href="#引用数组" class="headerlink" title="引用数组"></a>引用数组</h3><p>引用数组和引用构造器很像，格式为 类型[]::new，其中类型可以为基本类型也可以是类。如:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Function&lt;Integer, int[]&gt; fun = n -&gt; new int[n];</span></span><br><span class="line">Function&lt;Integer, <span class="keyword">int</span>[]&gt; fun = <span class="keyword">int</span>[]::<span class="keyword">new</span>;</span><br><span class="line"><span class="keyword">int</span>[] arr = fun.apply(<span class="number">10</span>);</span><br><span class="line">Function&lt;Integer, Integer[]&gt; fun2 = Integer[]::<span class="keyword">new</span>;</span><br><span class="line">Integer[] arr2 = fun2.apply(<span class="number">10</span>);</span><br></pre></td></tr></table></figure>

<h1 id="Optional类"><a href="#Optional类" class="headerlink" title="Optional类"></a>Optional类</h1><p>空指针异常是导致Java应用程序失败的最常见原因，以前，为了解决空指针异常，Google公司著名的Guava项目引入了Optional类，Guava通过使用检查空值的方式来防止代码污染，它鼓励程序员写更干净的代码。受到Google Guava的启发，Optional类已经成为Java 8类库的一部分。</p>
<p>Optional实际上是个容器：它可以保存类型T的值，或者仅仅保存null。Optional提供很多有用的方法，这样我们就不用显式进行空值检测。</p>
<p>创建Optional对象的几个方法：</p>
<ol>
<li>Optional.of(T value)， 返回一个Optional对象，value不能为空，否则会出空指针异常</li>
<li>Optional.ofNullable(T value)， 返回一个Optional对象，value可以为空</li>
<li>Optional.empty()，代表空</li>
</ol>
<p>其他API:</p>
<ol>
<li>optional.isPresent()，是否存在值（不为空）</li>
<li>optional.ifPresent(Consumer&lt;? super T&gt; consumer), 如果存在值则执行consumer</li>
<li>optional.get()，获取value</li>
<li>optional.orElse(T other)，如果没值则返回other</li>
<li>optional.orElseGet(Supplier&lt;? extends T&gt; other)，如果没值则执行other并返回</li>
<li>optional.orElseThrow(Supplier&lt;? extends X&gt; exceptionSupplier)，如果没值则执行exceptionSupplier，并抛出异常</li>
</ol>
<p>那么，我们之前对于防止空指针会这么写：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Order</span> </span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getOrderName</span><span class="params">(Order order)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (order == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> order.name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在用Optional，会改成：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Order</span> </span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getOrderName</span><span class="params">(Order order)</span> </span>&#123;</span><br><span class="line">        Optional&lt;Order&gt; orderOptional = Optional.ofNullable(order);</span><br><span class="line">        <span class="keyword">if</span> (!orderOptional.isPresent()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> orderOptional.get().name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么如果只是改成这样，实质上并没有什么分别，事实上<code>isPresent()</code> 与 <code>obj != null</code> 无任何分别，并且在使用<code>get()</code>之前最好都使用<code>isPresent()</code> ，比如下面的代码在IDEA中会有警告:<code>&#39;Optional.get()&#39; without &#39;isPresent()&#39; check</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createOrder</span><span class="params">(String userName)</span> </span>&#123;</span><br><span class="line">    Optional optional = Optional.ofNullable(userName);</span><br><span class="line">    optional.get();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>另外把 Optional 类型用作属性或是方法参数在<strong>IntelliJ IDEA</strong>中更是强力不推荐的。<br>对于上面的代码我们利用IDEA的提示可以优化成一行：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Order</span> </span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getOrderName</span><span class="params">(Order order )</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Optional.ofNullable(order).map(order1 -&gt; order1.name).orElse(<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个优化过程中map()起了很大作用。</p>
<p>高级API：</p>
<ol>
<li>optional.map(Function&lt;? super T, ? extends U&gt; mapper)，映射，映射规则由function指定，返回映射值的Optional，所以可以继续使用Optional的API。</li>
<li>optional.flatMap(Function&lt;? super T, Optional&lt; U &gt; &gt; mapper)，同map类似，区别在于map中获取的返回值自动被Optional包装，flatMap中返回值保持不变,但入参必须是Optional类型。</li>
<li>optional.filter(Predicate&lt;? super T&gt; predicate)，过滤，按predicate指定的规则进行过滤，不符合规则则返回empty，也可以继续使用Optional的API。</li>
</ol>
<blockquote>
<p>使用 Optional 时尽量不直接调用 <code>Optional.get()</code> 方法, <code>Optional.isPresent()</code> 更应该被视为一个私有方法, 应依赖于其他像 <code>Optional.orElse()</code>, <code>Optional.orElseGet()</code>, <code>Optional.map()</code> 等这样的方法。</p>
</blockquote>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java8</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux环境常用中间件部署</title>
    <url>/2022/08/18/Linux%E7%8E%AF%E5%A2%83%E5%B8%B8%E7%94%A8%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%83%A8%E7%BD%B2/</url>
    <content><![CDATA[<h1 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h1><p>安装</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo yum install -y gcc-c++ pcre pcre-devel zlib zlib-devel openssl openssl-devel wget</span><br><span class="line">wget http://nginx.org/download/nginx-1.22.0.tar.gz</span><br><span class="line">tar -zxvf nginx-1.22.0.tar.gz</span><br><span class="line">cd nginx-1.22.0</span><br><span class="line">./configure</span><br><span class="line">make</span><br><span class="line">sudo make install</span><br><span class="line">sudo ln -s /usr/local/nginx/sbin/nginx /usr/bin/nginx</span><br></pre></td></tr></table></figure>

<p>验证</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo nginx -v</span><br></pre></td></tr></table></figure>

<p>启动</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo nginx</span><br></pre></td></tr></table></figure>



<h1 id="OpenJDK-1-8（或OpenJRE-1-8）"><a href="#OpenJDK-1-8（或OpenJRE-1-8）" class="headerlink" title="OpenJDK 1.8（或OpenJRE 1.8）"></a>OpenJDK 1.8（或OpenJRE 1.8）</h1><p>安装JDK</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo yum install -y java-1.8.0-openjdk-devel</span><br></pre></td></tr></table></figure>

<p>或安装JRE</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo yum install -y java-1.8.0-openjdk</span><br></pre></td></tr></table></figure>

<p>验证</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">java -version</span><br></pre></td></tr></table></figure>


<h1 id="Maven（可选，脚本自动化安装推荐）"><a href="#Maven（可选，脚本自动化安装推荐）" class="headerlink" title="Maven（可选，脚本自动化安装推荐）"></a>Maven（可选，脚本自动化安装推荐）</h1><p>依赖JDK（JRE不能完全支持），待安装JDK之后，Maven官网下载对应版本的bin包：<a href="https://maven.apache.org/download.cgi">https://maven.apache.org/download.cgi</a> 。以下以3.6.3举例：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget https://mirrors.tuna.tsinghua.edu.cn/apache/maven/maven-3/3.6.3/binaries/apache-maven-3.6.3-bin.tar.gz</span><br><span class="line">tar -zxvf apache-maven-3.6.3-bin.tar.gz</span><br><span class="line">sudo mv apache-maven-3.6.3 /opt/apache-maven-3.6.3</span><br><span class="line">sudo update-alternatives --install /usr/bin/mvn mvn /opt/apache-maven-3.6.3/bin/mvn 0</span><br></pre></td></tr></table></figure>
<p>验证</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mvn -v</span><br></pre></td></tr></table></figure>


<h1 id="NodeJS（可选，脚本自动化安装推荐）"><a href="#NodeJS（可选，脚本自动化安装推荐）" class="headerlink" title="NodeJS（可选，脚本自动化安装推荐）"></a>NodeJS（可选，脚本自动化安装推荐）</h1><p>安装</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget https://nodejs.org/dist/v14.15.0/node-v14.15.0-linux-x64.tar.xz</span><br><span class="line">tar -Jxvf node-v14.15.0-linux-x64.tar.xz</span><br><span class="line">sudo mv node-v14.15.0-linux-x64 /opt/node-v14.15.0</span><br><span class="line">sudo ln -s /opt/node-v14.15.0/bin/node /usr/bin/node</span><br><span class="line">sudo ln -s /opt/node-v14.15.0/lib/node_modules/npm/bin/npm-cli.js /usr/bin/npm</span><br></pre></td></tr></table></figure>

<p>验证</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">node -v</span><br><span class="line">npm -v</span><br></pre></td></tr></table></figure>


<h1 id="MySQL-5-7-x"><a href="#MySQL-5-7-x" class="headerlink" title="MySQL 5.7.x"></a>MySQL 5.7.x</h1><p>安装</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget https://dev.mysql.com/get/mysql-community-release-el7-5.noarch.rpm</span><br><span class="line">sudo yum localinstall -y mysql-community-release-el7-5.noarch.rpm</span><br><span class="line">sudo yum install -y yum-utils</span><br><span class="line">sudo yum-config-manager --disable mysql56-community</span><br><span class="line">sudo yum-config-manager --enable mysql57-community-dmr</span><br><span class="line">sudo yum install -y mysql-server</span><br></pre></td></tr></table></figure>
<p>如果出现未安装密钥的错误，请执行</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rpm --import https://repo.mysql.com/RPM-GPG-KEY-mysql-2022</span><br></pre></td></tr></table></figure>

<p>启动验证</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo service mysqld start</span><br></pre></td></tr></table></figure>

<p>注意：初次安装好mysql server 5.7.x会随机生成root用户的登录密码，在修改root用户密码之前，不能进行任何有效操作，因此，需要使用控制台使用root用户登录并修改密码<br>查看随机密码<br>启动验证</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo grep &#x27;temporary password&#x27; /var/log/mysqld.log</span><br></pre></td></tr></table></figure>
<p>登录成功后，使用命令修改密码，新密码请使用实际的密码替代：</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">alter<span class="built_in"> user </span>root@localhost identified by <span class="string">&#x27;新密码&#x27;</span>;</span><br><span class="line">flush privileges;</span><br></pre></td></tr></table></figure>

<h1 id="Redis-6-0"><a href="#Redis-6-0" class="headerlink" title="Redis 6.0"></a>Redis 6.0</h1><p>安装</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo yum -y install centos-release-scl scl-utils-build glibc-static libstdc++-static</span><br><span class="line">sudo yum -y install devtoolset-9-binutils devtoolset-9-gcc devtoolset-9-gcc-c++</span><br><span class="line">scl enable devtoolset-9 bash</span><br><span class="line">wget http://download.redis.io/releases/redis-6.0.6.tar.gz</span><br><span class="line">tar -zxvf redis-6.0.6.tar.gz</span><br><span class="line">sudo mv redis-6.0.6 /opt/</span><br><span class="line">cd /opt/redis-6.0.6</span><br><span class="line">make</span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure>

<p>启动验证</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo redis-server /opt/redis-6.0.6/redis.conf &amp;</span><br></pre></td></tr></table></figure>

<p>Redis配置和启动<br>使用编辑器打开Redis的配置文件（需要root权限，或sudo操作）：/opt/redis-6.0.6/redis.conf<br>根据实际情况修改以下内容：</p>
<table>
<thead>
<tr>
<th>修改前</th>
<th>修改后</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>bind 127.0.0.1</code></td>
<td><code># bind 127.0.0.1</code></td>
<td>注释掉该行，取消只从本机访问的限制</td>
</tr>
<tr>
<td><code># requirepass foobared</code></td>
<td><code>requirepass 实际的密码</code></td>
<td>“实际的密码“请根据实际情况进行配置，并取消该行的注释</td>
</tr>
</tbody></table>
<p>重启Redis服务。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">redis-cli -a &#x27;实际的密码&#x27; shutdown</span><br><span class="line">sudo redis-server /opt/redis-6.0.6/redis.conf &amp;</span><br></pre></td></tr></table></figure>


<h1 id="Nacos"><a href="#Nacos" class="headerlink" title="Nacos"></a>Nacos</h1><figure class="highlight 1c"><table><tr><td class="code"><pre><span class="line">./startup.sh -m standalone <span class="meta">&amp;</span></span><br></pre></td></tr></table></figure>


<h1 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h1><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">nohup java -Xms512m -Xmx1g -XX:<span class="attribute">MetaspaceSize</span>=128m -XX:<span class="attribute">MaxMetaspaceSize</span>=512m -Dfile.<span class="attribute">encoding</span>=utf-8 -Dlog.<span class="attribute">path</span>=./logs -jar cas-auth.jar &gt;/dev/<span class="literal">null</span> 2&gt;&amp;1 &amp;</span><br></pre></td></tr></table></figure>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">java -javaagent:/data/apm-agent/elastic-apm-agent-1.33.0.jar -Delastic.apm.<span class="attribute">service_name</span>=cas-int-160 -Delastic.apm.<span class="attribute">server_urls</span>=http://172.16.40.163:8200 -Delastic.apm.<span class="attribute">environment</span>=staging -Delastic.apm.<span class="attribute">application_packages</span>=com.comac -Xms1g -Xmx2g -XX:<span class="attribute">MetaspaceSize</span>=128m -XX:<span class="attribute">MaxMetaspaceSize</span>=512m -Dfile.<span class="attribute">encoding</span>=utf-8 -Dlog.<span class="attribute">path</span>=./logs -jar cas-modules-system-exec.jar</span><br></pre></td></tr></table></figure>


<h1 id="新建用户"><a href="#新建用户" class="headerlink" title="新建用户"></a>新建用户</h1><figure class="highlight lasso"><table><tr><td class="code"><pre><span class="line">#adduser tommy</span><br><span class="line"><span class="comment">//添加一个名为tommy的用户</span></span><br><span class="line">#passwd tommy <span class="comment">//修改密码</span></span><br><span class="line">Changing password for user tommy.</span><br><span class="line"><span class="literal">New</span> UNIX password: <span class="comment">//在这里输入新密码</span></span><br><span class="line">Retype <span class="literal">new</span> UNIX password: <span class="comment">//再次输入新密码</span></span><br><span class="line">passwd: <span class="literal">all</span> authentication tokens updated successfully.</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>SpringBoot2.X快速构建和配置</title>
    <url>/2020/11/03/SpringBoot2-X%E5%BF%AB%E9%80%9F%E6%9E%84%E5%BB%BA%E5%92%8C%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<h1 id="SpringBoot是什么？"><a href="#SpringBoot是什么？" class="headerlink" title="SpringBoot是什么？"></a>SpringBoot是什么？</h1><p><img data-src="https://img-blog.csdnimg.cn/20181117220632243.png"><br>Spring Boot 是由 Pivotal 团队提供的全新框架。<br>Spring Boot 是所有基于 Spring Framework 5.0 开发的项目的起点。<br>Spring Boot 的设计是为了让你尽可能快的跑起来 Spring 应用程序并且尽可能减少你的配置文件。</p>
<a id="more"></a>

<p>从最根本上来讲，Spring Boot 就是一些库的集合，它能够被任意项目的构建系统所使用。它使用<em>习惯优于配置</em>（项目中存在大量的配置，此外还内置一个习惯性的配置）的理念让你的项目快速运行起来。用大佬的话来理解，就是 spring boot 其实不是什么新的框架，它默认配置了很多框架的使用方式，就像 maven 整合了所有的 jar 包，spring boot 整合了所有的框架，总结一下及几点：</p>
<ol>
<li>为所有 Spring 开发提供一个更快更广泛的入门体验。</li>
<li>零配置。无冗余代码生成和XML 强制配置，遵循<em>约定大于配置</em> 。</li>
<li>集成了大量常用的第三方库的配置， Spring Boot 应用为这些第三方库提供了几乎可以零配置的开箱即用的能力。</li>
<li>提供一系列大型项目常用的非功能性特征，如嵌入式服务器、安全性、度量、运行状况检查、外部化配置等。</li>
<li>Spring Boot 不是Spring 的替代者，Spring 框架是通过 IOC 机制来管理 Bean 的。Spring Boot 依赖 Spring 框架来管理对象的依赖。Spring Boot 并不是Spring 的精简版本，而是为使用 Spring 做好各种产品级准备</li>
</ol>
<h1 id="Spring-Boot-在应用中的角色"><a href="#Spring-Boot-在应用中的角色" class="headerlink" title="Spring Boot 在应用中的角色"></a>Spring Boot 在应用中的角色</h1><p>Spring Boot 是基于 Spring Framework 来构建的，Spring Framework 是一种 J2EE 的框架<br>Spring Boot 是一种快速构建 Spring 应用<br>Spring Cloud 是构建 Spring Boot 分布式环境，也就是常说的云应用<br>Spring Boot 中流砥柱，承上启下</p>
<h1 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h1><ol>
<li>JDK8以上。</li>
<li>建议安装Intellj Idea Ultimate（旗舰版）。</li>
<li>具备Maven和SpringMVC技术。</li>
</ol>
<h1 id="SpringBoot开发要求"><a href="#SpringBoot开发要求" class="headerlink" title="SpringBoot开发要求"></a>SpringBoot开发要求</h1><ol>
<li>创建Maven工程，构建项目结构。</li>
<li>配置pom.xml，引用各种starter启动器简化配置。</li>
<li>配置运行参数。</li>
<li>编码与测试。</li>
<li>打包与独立运行。</li>
</ol>
<h1 id="SpringBoot的目录结构"><a href="#SpringBoot的目录结构" class="headerlink" title="SpringBoot的目录结构"></a>SpringBoot的目录结构</h1><table>
<thead>
<tr>
<th>目录</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>/src/main</td>
<td>项目根目录</td>
</tr>
<tr>
<td>/java</td>
<td>Java源代码目录</td>
</tr>
<tr>
<td>/resources</td>
<td>资源目录</td>
</tr>
<tr>
<td>/resources/static</td>
<td>静态资源目录</td>
</tr>
<tr>
<td>/resources/templates</td>
<td>表示层页面目录</td>
</tr>
<tr>
<td>/resources/application.properties</td>
<td>静态资源目录</td>
</tr>
<tr>
<td>/test</td>
<td>测试文件目录</td>
</tr>
</tbody></table>
<h1 id="基本启动器"><a href="#基本启动器" class="headerlink" title="基本启动器"></a>基本启动器</h1><table>
<thead>
<tr>
<th>启动器</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>spring-boot-starter-parent</td>
<td>所有Spring Boot组件的基础引用</td>
</tr>
<tr>
<td>spring-boot-starter-web</td>
<td>提供web的支持</td>
</tr>
<tr>
<td>spring-boot-starter-thymeleaf</td>
<td>提供thymeleaf模板引擎的支持</td>
</tr>
<tr>
<td>spring-boot-maven-plugin</td>
<td>提供打包的支持</td>
</tr>
</tbody></table>
<h1 id="SpringBoot常用配置"><a href="#SpringBoot常用配置" class="headerlink" title="SpringBoot常用配置"></a>SpringBoot常用配置</h1><table>
<thead>
<tr>
<th>web常用配置</th>
<th>默认值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>debug</td>
<td>false</td>
<td>开启/关闭调试模式</td>
</tr>
<tr>
<td>server.port</td>
<td>8080</td>
<td>服务器脚本</td>
</tr>
<tr>
<td>server.servlet.context-path</td>
<td>/</td>
<td>应用上下文</td>
</tr>
<tr>
<td>spring.http.encoding.charset</td>
<td>utf-8</td>
<td>默认字符集编码</td>
</tr>
<tr>
<td>spring.thymeleaf.cache</td>
<td>true</td>
<td>开启/关闭页面缓存</td>
</tr>
<tr>
<td>spring.mvc.date-format</td>
<td></td>
<td>日期输入格式</td>
</tr>
<tr>
<td>spring.jackson.date-format</td>
<td></td>
<td>json输出的日期格式</td>
</tr>
<tr>
<td>spring.jackson.time-zone</td>
<td></td>
<td>设置GMT时区</td>
</tr>
</tbody></table>
<h1 id="日志配置"><a href="#日志配置" class="headerlink" title="日志配置"></a>日志配置</h1>]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux环境常用中间件部署（离线版）</title>
    <url>/2022/08/29/Linux%E7%8E%AF%E5%A2%83%E5%B8%B8%E7%94%A8%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%83%A8%E7%BD%B2%EF%BC%88%E7%A6%BB%E7%BA%BF%E7%89%88%EF%BC%89/</url>
    <content><![CDATA[<h1 id="JDK-1-8"><a href="#JDK-1-8" class="headerlink" title="JDK 1.8"></a>JDK 1.8</h1><ol>
<li><p>去Oracle官网下载需要安装的jdk版本，我这里用的是jdk-linux-x64.tar.gz  </p>
</li>
<li><p>使用xshell或者FinalShell上传工具将jdk压缩包上传到新建的文件夹中，我这里是/home/java</p>
</li>
<li><p>将上传的压缩包进行解压</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">tar</span> <span class="selector-tag">-zxvf</span> <span class="selector-tag">jdk-linux-x64</span><span class="selector-class">.tar</span><span class="selector-class">.gz</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>进行编辑配置文件</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">vi <span class="regexp">/etc/</span>profile</span><br></pre></td></tr></table></figure>
</li>
<li><p>在配置文件末尾加上环境变量配置</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line"><span class="comment"># jdk的解压目录</span></span><br><span class="line"><span class="builtin-name">export</span> <span class="attribute">JAVA_HOME</span>=/home/java/jdk1.8.0_131</span><br><span class="line"><span class="builtin-name">export</span> <span class="attribute">PATH</span>=<span class="variable">$PATH</span>:$JAVA_HOME/bin</span><br></pre></td></tr></table></figure>
</li>
<li><p>刷新配置文件</p>
<figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line"><span class="keyword">source</span> <span class="regexp">/etc/</span>profile</span><br></pre></td></tr></table></figure>
</li>
<li><p>验证</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">java -version</span><br></pre></td></tr></table></figure>


</li>
</ol>
<h1 id="MySQL-5-7-x"><a href="#MySQL-5-7-x" class="headerlink" title="MySQL 5.7.x"></a>MySQL 5.7.x</h1><ol>
<li><p>卸载CentOS自带的mariadb-lib（执行<code>rpm -qa|grep mariadb</code>有对应信息才卸载，没有不需要执行卸载）：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">rpm</span> <span class="string">-qa|grep mariadb</span></span><br><span class="line"><span class="attr">rpm</span> <span class="string">-e --nodeps mariadb-libs-xxxxx</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>解压后依次安装rpm包，由于rpm包有安装顺序，依次按顺序执行安装：</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">rpm</span> -ivh mysql-community-common-<span class="number">5</span>.<span class="number">7</span>.<span class="number">38</span>-<span class="number">1</span>.el<span class="number">7</span>.x<span class="number">86</span>_<span class="number">64</span>.rpm</span><br><span class="line"><span class="attribute">rpm</span> -ivh mysql-community-libs-<span class="number">5</span>.<span class="number">7</span>.<span class="number">38</span>-<span class="number">1</span>.el<span class="number">7</span>.x<span class="number">86</span>_<span class="number">64</span>.rpm</span><br><span class="line"><span class="attribute">rpm</span> -ivh mysql-community-client-<span class="number">5</span>.<span class="number">7</span>.<span class="number">38</span>-<span class="number">1</span>.el<span class="number">7</span>.x<span class="number">86</span>_<span class="number">64</span>.rpm</span><br><span class="line"><span class="attribute">rpm</span> -ivh mysql-community-server-<span class="number">5</span>.<span class="number">7</span>.<span class="number">38</span>-<span class="number">1</span>.el<span class="number">7</span>.x<span class="number">86</span>_<span class="number">64</span>.rpm</span><br></pre></td></tr></table></figure>
</li>
<li><p>配置my.cnf，开启表名忽略大小写(如果不需要此功能可以略过此步骤)：</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">vi <span class="regexp">/etc/my</span>.cnf</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>在[mysqld]下面加入：</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="attr">lower_case_table_names</span> = <span class="number">1</span></span><br></pre></td></tr></table></figure>

<ol start="4">
<li><p>启动验证</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo service mysqld start</span><br></pre></td></tr></table></figure>
</li>
<li><p>登陆并修改密码<br>注意：初次安装好mysql server 5.7.x会随机生成root用户的登录密码，在修改root用户密码之前，不能进行任何有效操作，因此，需要使用控制台使用root用户登录并修改密码<br>查看随机密码<br>启动验证</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo grep &#x27;temporary password&#x27; /var/log/mysqld.log</span><br></pre></td></tr></table></figure>
<p>登录成功后，使用命令修改密码，新密码请使用实际的密码替代：</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">alter<span class="built_in"> user </span>root@localhost identified by <span class="string">&#x27;新密码&#x27;</span>;</span><br><span class="line">flush privileges;</span><br></pre></td></tr></table></figure>
</li>
<li><p>开启远程登录授权</p>
</li>
</ol>
<figure class="highlight n1ql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">schema</span> adms_system <span class="keyword">collate</span> utf8_general_ci;</span><br></pre></td></tr></table></figure>

<h1 id="Redis-6-0"><a href="#Redis-6-0" class="headerlink" title="Redis 6.0"></a>Redis 6.0</h1><p>安装</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tar -zxvf redis-6.0.6.tar.gz</span><br><span class="line">sudo mv redis-6.0.6 /opt/</span><br><span class="line">cd /opt/redis-6.0.6</span><br><span class="line">make</span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure>

<p>将命令设置为全局</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">ln -s <span class="regexp">/usr/</span>local<span class="regexp">/redis/</span>redis-<span class="number">6.2</span>.<span class="number">6</span><span class="regexp">/src/</span>redis-server <span class="regexp">/usr/</span>bin/redis-server</span><br></pre></td></tr></table></figure>

<p>启动验证</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo redis-server /opt/redis-6.0.6/redis.conf &amp;</span><br></pre></td></tr></table></figure>

<p>Redis配置和启动<br>使用编辑器打开Redis的配置文件（需要root权限，或sudo操作）：/opt/redis-6.0.6/redis.conf<br>根据实际情况修改以下内容：</p>
<table>
<thead>
<tr>
<th>修改前</th>
<th>修改后</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>bind 127.0.0.1</code></td>
<td><code># bind 127.0.0.1</code></td>
<td>注释掉该行，取消只从本机访问的限制</td>
</tr>
<tr>
<td><code># requirepass foobared</code></td>
<td><code>requirepass 实际的密码</code></td>
<td>“实际的密码“请根据实际情况进行配置，并取消该行的注释</td>
</tr>
</tbody></table>
<p>重启Redis服务。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">redis-cli -a &#x27;实际的密码&#x27; shutdown</span><br><span class="line">sudo redis-server /opt/redis-6.0.6/redis.conf &amp;</span><br></pre></td></tr></table></figure>


<h1 id="Nacos"><a href="#Nacos" class="headerlink" title="Nacos"></a>Nacos</h1><figure class="highlight 1c"><table><tr><td class="code"><pre><span class="line">./startup.sh -m standalone <span class="meta">&amp;</span></span><br></pre></td></tr></table></figure>



<h1 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h1><p>安装</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tar -zxvf nginx-1.22.0.tar.gz</span><br><span class="line">cd nginx-1.22.0</span><br><span class="line">./configure</span><br><span class="line">make</span><br><span class="line">sudo make install</span><br><span class="line">sudo ln -s /usr/local/nginx/sbin/nginx /usr/bin/nginx</span><br></pre></td></tr></table></figure>

<p>验证</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo nginx -v</span><br></pre></td></tr></table></figure>

<p>启动</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo nginx</span><br></pre></td></tr></table></figure>

<p>配置修改</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">listen</span>       <span class="number">28080</span>;</span><br><span class="line"></span><br><span class="line"><span class="attribute">location</span> / &#123;</span><br><span class="line">    <span class="attribute">etag</span> <span class="literal">on</span>;</span><br><span class="line">    <span class="attribute">root</span>   /data/adms/web/dist;</span><br><span class="line">    <span class="attribute">index</span>  index.html index.htm;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="attribute">location</span><span class="regexp"> ^~/prod-api/</span> &#123;</span><br><span class="line">    <span class="attribute">proxy_pass</span>              http://127.0.0.1:8080/;</span><br><span class="line">    <span class="attribute">proxy_http_version</span>      <span class="number">1</span>.<span class="number">1</span>;</span><br><span class="line">    <span class="attribute">proxy_set_header</span>        Upgrade         <span class="variable">$http_upgrade</span>;</span><br><span class="line">    <span class="attribute">proxy_set_header</span>        Connection      <span class="string">&quot;upgrade&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h1><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">nohup java -Xms512m -Xmx1g -XX:<span class="attribute">MetaspaceSize</span>=128m -XX:<span class="attribute">MaxMetaspaceSize</span>=512m -Dfile.<span class="attribute">encoding</span>=utf-8 -Dlog.<span class="attribute">path</span>=./logs -jar cas-auth.jar &gt;/dev/<span class="literal">null</span> 2&gt;&amp;1 &amp;</span><br></pre></td></tr></table></figure>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">java -javaagent:/data/apm-agent/elastic-apm-agent-1.33.0.jar -Delastic.apm.<span class="attribute">service_name</span>=cas-int-160 -Delastic.apm.<span class="attribute">server_urls</span>=http://172.16.40.163:8200 -Delastic.apm.<span class="attribute">environment</span>=staging -Delastic.apm.<span class="attribute">application_packages</span>=com.comac -Xms1g -Xmx2g -XX:<span class="attribute">MetaspaceSize</span>=128m -XX:<span class="attribute">MaxMetaspaceSize</span>=512m -Dfile.<span class="attribute">encoding</span>=utf-8 -Dlog.<span class="attribute">path</span>=./logs -jar cas-modules-system-exec.jar</span><br></pre></td></tr></table></figure>


<h1 id="新建用户"><a href="#新建用户" class="headerlink" title="新建用户"></a>新建用户</h1><figure class="highlight lasso"><table><tr><td class="code"><pre><span class="line">#adduser tommy</span><br><span class="line"><span class="comment">//添加一个名为tommy的用户</span></span><br><span class="line">#passwd tommy <span class="comment">//修改密码</span></span><br><span class="line">Changing password for user tommy.</span><br><span class="line"><span class="literal">New</span> UNIX password: <span class="comment">//在这里输入新密码</span></span><br><span class="line">Retype <span class="literal">new</span> UNIX password: <span class="comment">//再次输入新密码</span></span><br><span class="line">passwd: <span class="literal">all</span> authentication tokens updated successfully.</span><br></pre></td></tr></table></figure>




<h1 id="防火墙"><a href="#防火墙" class="headerlink" title="防火墙"></a>防火墙</h1><ol>
<li><p>开启防火墙 </p>
<figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">systemctl <span class="literal">start</span> firewalld</span><br></pre></td></tr></table></figure>
</li>
<li><p>开放指定端口</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">firewall-cmd <span class="attribute">--zone</span>=public <span class="attribute">--add-port</span>=1935/tcp --permanent</span><br></pre></td></tr></table></figure>
<p>命令含义：  </p>
</li>
</ol>
<p>–zone #作用域<br>–add-port=1935/tcp  #添加端口，格式为：端口/通讯协议<br>–permanent  #永久生效，没有此参数重启后失效  </p>
<ol start="3">
<li>重启防火墙<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line">firewall-<span class="keyword">cmd</span><span class="bash"> --reload</span></span><br></pre></td></tr></table></figure></li>
<li>查看端口号<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line"><span class="regexp">//</span>查看当前所有tcp端口</span><br><span class="line"></span><br><span class="line">netstat -ntlp</span><br><span class="line"></span><br><span class="line"><span class="regexp">//</span>查看所有<span class="number">1935</span>端口使用情况</span><br><span class="line"></span><br><span class="line">netstat -ntulp |grep <span class="number">1935</span></span><br></pre></td></tr></table></figure>







</li>
</ol>
<h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1>]]></content>
  </entry>
  <entry>
    <title>SpringCloud组件之eureka（注册中心）</title>
    <url>/2020/10/27/SpringCloud%E7%BB%84%E4%BB%B6%E4%B9%8Beureka%EF%BC%88%E6%90%AD%E5%BB%BA%E3%80%81%E9%9B%86%E7%BE%A4%E3%80%81%E5%BF%83%E8%B7%B3%EF%BC%89/</url>
    <content><![CDATA[<h1 id="eureka"><a href="#eureka" class="headerlink" title="eureka"></a>eureka</h1><h2 id="eureka是什么？"><a href="#eureka是什么？" class="headerlink" title="eureka是什么？"></a>eureka是什么？</h2><p>eureka是Netflix的子模块之一，也是一个核心的模块，eureka里有2个组件，一个是EurekaServer(一个独立的项目) 这个是用于定位服务以实现中间层服务器的负载平衡和故障转移，另一个便是EurekaClient（我们的微服务）它是用于与Server交互的，可以使得交互变得非常简单：只需要通过服务标识符即可拿到服务。</p>
<a id="more"></a>

<h2 id="与spring-cloud的关系"><a href="#与spring-cloud的关系" class="headerlink" title="与spring-cloud的关系"></a>与spring-cloud的关系</h2><p>Spring Cloud 封装了 Netflix 公司开发的 Eureka 模块来实现服务注册和发现(可以对比Zookeeper)。<br>Eureka 采用了 C-S 的设计架构。Eureka Server 作为服务注册功能的服务器，它是服务注册中心。<br>而系统中的其他微服务，使用 Eureka 的客户端连接到 Eureka Server并维持心跳连接。这样系统的维护人员就可以通过 Eureka Server 来监控系统中各个微服务是否正常运行。SpringCloud 的一些其他模块（比如Zuul）就可以通过 Eureka Server 来发现系统中的其他微服务，并执行相关的逻辑。</p>
<h2 id="eureka角色关系"><a href="#eureka角色关系" class="headerlink" title="eureka角色关系"></a>eureka角色关系</h2><p><img data-src="https://i.loli.net/2020/10/27/fTMlspmcJDznq9i.png" alt="eureka角色关系.png"></p>
<h2 id="如何使用？"><a href="#如何使用？" class="headerlink" title="如何使用？"></a>如何使用？</h2><p>在spring-cloud项目里面加入依赖：<br>eureka客户端：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>eureka服务端：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p> eureka服务端项目里面加入以下配置：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">3000</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">server:</span></span><br><span class="line">    <span class="attr">enable-self-preservation:</span> <span class="literal">false</span>  <span class="comment">#关闭自我保护机制</span></span><br><span class="line">    <span class="attr">eviction-interval-timer-in-ms:</span> <span class="number">4000</span> <span class="comment">#设置清理间隔（单位：毫秒 默认是60*1000）</span></span><br><span class="line">  <span class="attr">instance:</span></span><br><span class="line">    <span class="attr">hostname:</span> <span class="string">localhost</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">registerWithEureka:</span> <span class="literal">false</span> <span class="comment">#不把自己作为一个客户端注册到自己身上</span></span><br><span class="line">    <span class="attr">fetchRegistry:</span> <span class="literal">false</span>  <span class="comment">#不需要从服务端获取注册信息（因为在这里自己就是服务端，而且已经禁用自己注册了）</span></span><br><span class="line">    <span class="attr">serviceUrl:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://$&#123;eureka.instance.hostname&#125;:$&#123;server.port&#125;/eureka</span></span><br></pre></td></tr></table></figure>
<p> 当然，不是全部必要的，这里只是把我这里的配置copy过来了<br> 然后在spring-boot启动项目上 加入注解<code>@EnableEurekaServer</code>就可以启动项目了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableEurekaServer</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppEureka</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(AppEureka.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果看见这个图片，那么说明你就搭建好了:<br><img data-src="https://i.loli.net/2020/10/27/bax5Pjp9zkF8fJn.png" alt="eureka首页.png"></p>
<p><em>注：图片中警告只是说你把他的自我保护机制关闭了</em></p>
<p>eureka客户端配置:</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">6000</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">serviceUrl:</span></span><br><span class="line">        <span class="attr">defaultZone:</span> <span class="string">http://localhost:3000/eureka/</span>  <span class="comment">#eureka服务端提供的注册地址 参考服务端配置的这个路径</span></span><br><span class="line">  <span class="attr">instance:</span></span><br><span class="line">    <span class="attr">instance-id:</span> <span class="string">power-1</span> <span class="comment">#此实例注册到eureka服务端的唯一的实例ID </span></span><br><span class="line">    <span class="attr">prefer-ip-address:</span> <span class="literal">true</span> <span class="comment">#是否显示IP地址</span></span><br><span class="line">    <span class="attr">leaseRenewalIntervalInSeconds:</span> <span class="number">10</span> <span class="comment">#eureka客户需要多长时间发送心跳给eureka服务器，表明它仍然活着，默认为30秒 (与下面配置的单位都是秒)</span></span><br><span class="line">    <span class="attr">leaseExpirationDurationInSeconds:</span> <span class="number">30</span> <span class="comment">#Eureka服务器在接收到实例的最后一次发出的心跳后，需要等待多久才可以将此实例删除，默认为90秒</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">server-power</span> <span class="comment">#此实例注册到eureka服务端的name </span></span><br></pre></td></tr></table></figure>
<p>然后在客户端的spring-boot启动项目上加入注解<code>@EnableEurekaClient</code>就可以启动项目了，这里就不截图了我们直接来看效果图：<br><img data-src="https://i.loli.net/2020/10/27/bax5Pjp9zkF8fJn.png" alt="eureka首页.png"></p>
<p>这里我们能看见 名字叫<em>server-power</em>的（图中将其大写了）,id为<em>power-1</em>的服务注册到我们的Eureka上面来了 至此，一个简单的eureka已经搭建好了。</p>
<h1 id="eureka集群"><a href="#eureka集群" class="headerlink" title="eureka集群"></a>eureka集群</h1><h2 id="eureka集群原理"><a href="#eureka集群原理" class="headerlink" title="eureka集群原理"></a>eureka集群原理</h2><p>服务启动后向Eureka注册，Eureka Server会将注册信息向其他Eureka Server进行同步，当服务消费者要调用服务提供者，则向服务注册中心获取服务提供者地址，然后会将服务提供者地址缓存在本地，下次再调用时，则直接从本地缓存中取，完成一次调用。</p>
<h2 id="eureka集群配置"><a href="#eureka集群配置" class="headerlink" title="eureka集群配置"></a>eureka集群配置</h2><p>刚刚我们了解到 Eureka Server会将注册信息向其他Eureka Server进行同步，那么我们得声明有哪些server呢？<br>这里假设我们有3个Eureka Server如图：<br><img data-src="https://i.loli.net/2020/10/27/euiSHPbv9tFpJCs.png" alt="eurekaserver.png"></p>
<p>现在怎么声明集群环境的server呢？ 我们看一张图：<br><img data-src="https://i.loli.net/2020/10/27/mMVUvdhpsw3tkfW.png" alt="eureka角色关系.png"></p>
<p>可能看着有点抽象，我们来看看具体配置</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">3000</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">server:</span></span><br><span class="line">    <span class="attr">enable-self-preservation:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">eviction-interval-timer-in-ms:</span> <span class="number">4000</span></span><br><span class="line">  <span class="attr">instance:</span></span><br><span class="line">    <span class="attr">hostname:</span> <span class="string">eureka3000.com</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">registerWithEureka:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">fetchRegistry:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">serviceUrl:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://eureka3001.com:3001/eureka,http://eureka3002.com:3002/eureka</span></span><br></pre></td></tr></table></figure>
<p>这里 方便理解集群 我们做了一个域名的映射(条件不是特别支持我使用三台笔记本来测试。。。) 至于域名怎么映射的话 这里简单提一下吧 修改你的hosts文件（win10的目录在C:\Windows\System32\drivers\etc 其他系统的话自行百度一下把）附上我的hosts文件：</p>
<figure class="highlight accesslog"><table><tr><td class="code"><pre><span class="line"><span class="number">127.0.0.1</span>  eureka3000.com</span><br><span class="line"><span class="number">127.0.0.1</span>  eureka3001.com</span><br><span class="line"><span class="number">127.0.0.1</span>  eureka3002.com</span><br></pre></td></tr></table></figure>
<p>我们回到主题，我们发现，集群配置与单体不同的点在于，单体是把服务注册到自己身上，而集群是注册到其它服务身上<br>至于为什么不注册自己了呢？回到最上面我们说过，eureka的server会把自己的注册信息与其他的server同步，所以这里我们不需要注册到自己身上，因为另外两台服务器会配置本台服务器。(这里可能有点绕，可以参考一下刚刚那张集群环境的图，或者自己动手配置一下，另外两台eureka的配置与这个是差不多的，就不发出来了，只要注意是注册到其他的服务上面就好了)<br>当三台eureka配置好之后，全部启动一下就可以看见效果了:<br><img data-src="https://i.loli.net/2020/10/27/N2vOhdqYSFA3MH7.png" alt="eureka集群注册.png"></p>
<p>当然，我们这里仅仅是把服务端配置好了， 那客户端怎么配置呢？ 话不多说，上代码：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">client:</span></span><br><span class="line">  <span class="attr">serviceUrl:</span></span><br><span class="line">    <span class="attr">defaultZone:</span> <span class="string">http://localhost:3000/eureka/,http://eureka3001.com:3001/eureka,http://eureka3002.com:3002/eureka</span></span><br></pre></td></tr></table></figure>

<p>我们这里只截取了要改动的那一部分。就是原来是注册到那一个地址上面，现在是要写三个eureka注册地址，但是不是代表他会注册三次，因为我们eureka server的注册信息是同步的，这里只需要注册一次就可以了，但是为什么要写三个地址呢。因为这样就可以做到高可用的配置：打个比方有3台服务器。但是突然宕机了一台，但是其他2台还健在，依然可以注册我们的服务，换句话来讲，只要有一台服务还建在，那么就可以注册服务。<br>这里效果图就不发了，和之前单机的没什么两样，只是你服务随便注册到哪个eureka server上其他的eureka server上都有该服务的注册信息。</p>
<h1 id="CAP定理的含义"><a href="#CAP定理的含义" class="headerlink" title="CAP定理的含义"></a>CAP定理的含义</h1><p>分布式系统（distributed system）正变得越来越重要，大型网站几乎都是分布式的。</p>
<p>分布式系统的最大难点，就是各个节点的状态如何同步。CAP定理是这方面的基本定理，也是理解分布式系统的起点。</p>
<h2 id="分布式系统的三个指标"><a href="#分布式系统的三个指标" class="headerlink" title="分布式系统的三个指标"></a>分布式系统的三个指标</h2><p><img data-src="https://www.wangbase.com/blogimg/asset/201807/bg2018071607.jpg"></p>
<p>1998年，加州大学的计算机科学家<em>Eric Brewer</em>提出，分布式系统有三个指标。</p>
<ul>
<li>Consistency</li>
<li>Availability</li>
<li>Partition tolerance</li>
</ul>
<p>它们的第一个字母分别是 C、A、P。</p>
<p><em>Eric Brewer</em>说，这三个指标不可能同时做到。这个结论就叫做 CAP 定理。</p>
<h2 id="Partition-tolerance（分区容错）"><a href="#Partition-tolerance（分区容错）" class="headerlink" title="Partition tolerance（分区容错）"></a>Partition tolerance（分区容错）</h2><p>先看 Partition tolerance，中文叫做”分区容错”。</p>
<p>大多数分布式系统都分布在多个子网络。每个子网络就叫做一个区（partition）。分区容错的意思是，区间通信可能失败。比如，一台服务器放在中国，另一台服务器放在美国，这就是两个区，它们之间可能无法通信。</p>
<p><img data-src="https://www.wangbase.com/blogimg/asset/201807/bg2018071601.png"></p>
<p>上图中，G1 和 G2 是两台跨区的服务器。G1 向 G2 发送一条消息，G2 可能无法收到。系统设计的时候，必须考虑到这种情况。</p>
<p>一般来说，分区容错无法避免，因此可以认为CAP的P总是成立。CAP定理告诉我们，剩下的C和A无法同时做到。</p>
<h2 id="Consistency（一致性）"><a href="#Consistency（一致性）" class="headerlink" title="Consistency（一致性）"></a>Consistency（一致性）</h2><p>Consistency 中文叫做”一致性”。意思是，写操作之后的读操作，必须返回该值。举例来说，某条记录是 v0，用户向 G1 发起一个写操作，将其改为 v1。<br><img data-src="https://www.wangbase.com/blogimg/asset/201807/bg2018071602.png"></p>
<p>接下来，用户的读操作就会得到 v1。这就叫一致性。<br><img data-src="https://www.wangbase.com/blogimg/asset/201807/bg2018071603.png"><br>问题是，用户有可能向 G2 发起读操作，由于 G2 的值没有发生变化，因此返回的是 v0。G1 和 G2 读操作的结果不一致，这就不满足一致性了。<br><img data-src="https://www.wangbase.com/blogimg/asset/201807/bg2018071604.png"><br>为了让 G2 也能变为 v1，就要在 G1 写操作的时候，让 G1 向 G2 发送一条消息，要求 G2 也改成 v1。<br><img data-src="https://www.wangbase.com/blogimg/asset/201807/bg2018071605.png"><br>这样的话，用户向 G2 发起读操作，也能得到 v1。<br><img data-src="https://www.wangbase.com/blogimg/asset/201807/bg2018071606.png">  </p>
<h2 id="Availability（可用性）"><a href="#Availability（可用性）" class="headerlink" title="Availability（可用性）"></a>Availability（可用性）</h2><p>Availability 中文叫做”可用性”，意思是只要收到用户的请求，服务器就必须给出回应。</p>
<p>用户可以选择向 G1 或 G2 发起读操作。不管是哪台服务器，只要收到请求，就必须告诉用户，到底是 v0 还是 v1，否则就不满足可用性。</p>
<h2 id="Consistency-和-Availability-的矛盾"><a href="#Consistency-和-Availability-的矛盾" class="headerlink" title="Consistency 和 Availability 的矛盾"></a>Consistency 和 Availability 的矛盾</h2><p>一致性和可用性，为什么不可能同时成立？答案很简单，因为可能通信失败（即出现分区容错）。</p>
<p>如果保证 G2 的一致性，那么 G1 必须在写操作时，锁定 G2 的读操作和写操作。只有数据同步后，才能重新开放读写。锁定期间，G2 不能读写，没有可用性不。</p>
<p>如果保证 G2 的可用性，那么势必不能锁定 G2，所以一致性不成立。</p>
<p>综上所述，G2 无法同时做到一致性和可用性。系统设计时只能选择一个目标。如果追求一致性，那么无法保证所有节点的可用性；如果追求所有节点的可用性，那就没法做到一致性。</p>
<h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p>在什么场合，可用性高于一致性？</p>
<p>举例来说，发布一张网页到 CDN，多个服务器有这张网页的副本。后来发现一个错误，需要更新网页，这时只能每个服务器都更新一遍。</p>
<p>一般来说，网页的更新不是特别强调一致性。短时期内，一些用户拿到老版本，另一些用户拿到新版本，问题不会特别大。当然，所有人最终都会看到新版本。所以，这个场合就是可用性高于一致性。</p>
<h1 id="eureka对比Zookeeper"><a href="#eureka对比Zookeeper" class="headerlink" title="eureka对比Zookeeper"></a>eureka对比Zookeeper</h1><p>Zookeeper在设计的时候遵循的是CP原则，即一致性,Zookeeper会出现这样一种情况，当master节点因为网络故障与其他节点失去联系时剩余节点会重新进行leader选举，问题在于，选举leader的时间太长：30~120s，且选举期间整个Zookeeper集群是不可用的，这就导致在选举期间注册服务处于瘫痪状态，在云部署的环境下，因网络环境使Zookeeper集群失去master节点是较大概率发生的事情，虽然服务能够最终恢复，但是漫长的选举时间导致长期的服务注册不可用是不能容忍的。<br>Eureka在设计的时候遵循的是AP原则，即可用性。Eureka各个节点（服务)是平等的， 没有主从之分，几个节点down掉不会影响正常工作，剩余的节点（服务） 依然可以提供注册与查询服务，而Eureka的客户端在向某个Eureka注册或发现连接失败，则会自动切换到其他节点，也就是说，只要有一台Eureka还在，就能注册可用（保证可用性）， 只不过查询到的信息不是最新的（不保证强一致），除此之外，Eureka还有自我保护机制，如果在15分钟内超过85%节点都没有正常心跳，那么eureka就认为客户端与注册中心出现了网络故障，此时会出现一下情况：  </p>
<ol>
<li>Eureka不再从注册列表中移除因为长时间没有收到心跳而过期的服务</li>
<li>Eureka仍然能够接收新服务的注册和查询请求，但是不会被同步到其它节点上（即保证当前节点可用）</li>
<li>当网络稳定后，当前实例新的注册信息会被同步到其它节点中</li>
</ol>
]]></content>
      <categories>
        <category>Spring微服务</category>
      </categories>
      <tags>
        <tag>SpringCloud</tag>
        <tag>Eureka</tag>
      </tags>
  </entry>
  <entry>
    <title>从零搭建本地代码仓库</title>
    <url>/2021/10/09/%E4%BB%8E%E9%9B%B6%E6%90%AD%E5%BB%BA%E6%9C%AC%E5%9C%B0%E4%BB%A3%E7%A0%81%E4%BB%93%E5%BA%93/</url>
    <content><![CDATA[<p>本篇完全面向入门者。我假设你从零开始创建一个项目并且想用 Git 来进行版本控制，我们会讨论如何在你的个人项目中使用 Git ，比如如何初始化你的项目，如何管理新的或者已有的文件，如何在远端仓库中储存你的代码。</p>
<a id="more"></a>

<h1 id="快速指南"><a href="#快速指南" class="headerlink" title="快速指南"></a>快速指南</h1><p>这节是完全面向入门者的，我假设你从零开始创建一个项目并且想用 Git 来进行版本控制，因此本文会避开分支这些相对复杂的概念。</p>
<p>在这节中，我会介绍如何在你的个人项目中使用 Git，我们会讨论 Git最基本的操作——如何初始化你的项目，如何管理新的或者已有的文件，如何在远端仓库中储存你的代码。</p>
<h2 id="安装-Git"><a href="#安装-Git" class="headerlink" title="安装 Git"></a>安装 Git</h2><ul>
<li>Mac 用户：Xcode Command Line Tools 自带 Git (xcode-select –install)</li>
<li>Linux 用户：sudo apt-get install git</li>
<li>Windows 用户：下载 <a href="https://git-scm.com/">Git</a>，对于 Windows 用户，安装后如果希望在全局的 cmd 中使用 git，需要把 git.exe 加入 PATH 环境变量中，或在 Git Bash 中使用 Git。</li>
</ul>
<h2 id="检出仓库"><a href="#检出仓库" class="headerlink" title="检出仓库"></a>检出仓库</h2><p>执行如下命令以创建一个本地仓库的克隆版本： <code>git clone /path/to/repository</code><br>如果是远端服务器上的仓库，你的命令会是这个样子： <code>git clone username@host:/path/to/repository</code> （通过 SSH） 或者： <code>git clone https:/path/to/repository.git</code> （通过 https）</p>
<h2 id="创建新仓库"><a href="#创建新仓库" class="headerlink" title="创建新仓库"></a>创建新仓库</h2><p>创建新文件夹，打开，然后执行 <code>git init</code> 以创建新的 git 仓库。</p>
<h2 id="工作流"><a href="#工作流" class="headerlink" title="工作流"></a>工作流</h2><p>你的本地仓库由 git 维护的三棵“树”组成。第一个是你的 工作目录，它持有实际文件；第二个是 缓存区（Index），它像个缓存区域，临时保存你的改动；最后是 HEAD，指向你最近一次提交后的结果。<br><img data-src="https://camo.githubusercontent.com/6e52beb12c47b2972937c8ae214e21eaa3647777c28936925ebf78ca0038157c/687474703a2f2f7777772e626f6f746373732e636f6d2f702f6769742d67756964652f696d672f74726565732e706e67" alt="图"></p>
<p>事实上，第三个阶段是 commit history 的图。HEAD 一般是指向最新一次 commit 的引用。现在暂时不必究其细节。</p>
<h2 id="添加与提交"><a href="#添加与提交" class="headerlink" title="添加与提交"></a>添加与提交</h2><p>你可以计划改动（把它们添加到缓存区），使用如下命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git add &lt; filename &gt;</span><br><span class="line">git add *</span><br></pre></td></tr></table></figure>
<p>这是 git 基本工作流程的第一步。使用如下命令以实际提交改动：</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">git</span> commit -m <span class="string">&quot;代码提交信息&quot;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>在开发时，良好的习惯是根据工作进度及时 commit，并务必注意附上有意义的 commit message。创建完项目目录后，第一次提交的 commit message 一般为「Initial commit.」。</p>
</blockquote>
<h2 id="推送改动"><a href="#推送改动" class="headerlink" title="推送改动"></a>推送改动</h2><p>你的改动现在已经在本地仓库的 HEAD 中了。执行如下命令以将这些改动提交到远端仓库：</p>
<figure class="highlight maxima"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">push</span> <span class="built_in">origin</span> master</span><br></pre></td></tr></table></figure>
<p>可以把 master 换成你想要推送的任何分支。</p>
<p>如果你还没有克隆现有仓库，并欲将你的仓库连接到某个远程服务器，你可以使用如下命令添加：</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line">git remote <span class="keyword">add</span><span class="bash"> origin &lt;server&gt;</span></span><br></pre></td></tr></table></figure>
<p>如此你就能够将你的改动推送到所添加的服务器上去了。</p>
<blockquote>
<ul>
<li>这里 origin 是 &lt; server &gt; 的别名，取什么名字都可以，你也可以在 push 时将 &lt; server &gt; 替换为 origin。但为了以后 push 方便，我们第一次一般都会先 remote add。</li>
<li>如果你还没有 git 仓库，可以在 GitHub 等代码托管平台上创建一个空（不要自动生成 README.md）的 repository，然后将代码 push 到远端仓库。</li>
</ul>
</blockquote>
<h1 id="创建代码仓库"><a href="#创建代码仓库" class="headerlink" title="创建代码仓库"></a>创建代码仓库</h1><h2 id="git-init"><a href="#git-init" class="headerlink" title="git init"></a>git init</h2><h2 id="git-clone"><a href="#git-clone" class="headerlink" title="git clone"></a>git clone</h2><h1 id="保存你的更改"><a href="#保存你的更改" class="headerlink" title="保存你的更改"></a>保存你的更改</h1><h1 id="检查仓库状态"><a href="#检查仓库状态" class="headerlink" title="检查仓库状态"></a>检查仓库状态</h1><h1 id="检出之前的提交"><a href="#检出之前的提交" class="headerlink" title="检出之前的提交"></a>检出之前的提交</h1><h1 id="回滚错误的修改"><a href="#回滚错误的修改" class="headerlink" title="回滚错误的修改"></a>回滚错误的修改</h1><h1 id="重写项目历史"><a href="#重写项目历史" class="headerlink" title="重写项目历史"></a>重写项目历史</h1>]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>从零搭建本地代码仓库</tag>
      </tags>
  </entry>
  <entry>
    <title>CAS系统服务器部署文档（Cylin系统）</title>
    <url>/2022/08/31/CAS%E7%B3%BB%E7%BB%9F%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%83%A8%E7%BD%B2%E6%96%87%E6%A1%A3%EF%BC%88Cylin%E7%B3%BB%E7%BB%9F%EF%BC%89/</url>
    <content><![CDATA[<h1 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h1><h2 id="安装包明细"><a href="#安装包明细" class="headerlink" title="安装包明细"></a>安装包明细</h2><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">data</span><br><span class="line">  ├── adms                                                </span><br><span class="line">  │     ├── server                                        </span><br><span class="line">  │     │     └── server.tar.gz                           // 应用后端代码</span><br><span class="line">  │     │ </span><br><span class="line">  │     └── web                                           </span><br><span class="line">  │           └── dist.tar.gz                             // 应用web端代码</span><br><span class="line">  │</span><br><span class="line">  ├── java                                                </span><br><span class="line">  │     └── jdk-8u341-linux-x64.tar.gz                    // jdk压缩包</span><br><span class="line">  │</span><br><span class="line">  ├── mysql                                               </span><br><span class="line">  │     └── mysql-5.7.38-1.el7.x86_64.rpm-bundle.tar      // Mysql数据库程序包</span><br><span class="line">  │</span><br><span class="line">  ├── nacos                                               </span><br><span class="line">  │     └── nacos-server-2.0.3.tar.gz                     // Nacos程序包</span><br><span class="line">  │</span><br><span class="line">  ├── nginx                                               </span><br><span class="line">  │     └── nginx-1.22.0.tar.gz                           // Nginx程序包</span><br><span class="line">  │</span><br><span class="line">  ├── redis                                               </span><br><span class="line">  │     └── redis-6.2.7.tar.gz                            // Redis程序包</span><br><span class="line">  │</span><br><span class="line">  └── tools</span><br><span class="line">        ├── lsof-4.93.2-4.ky10.x86_64.rpm                 </span><br><span class="line">        ├── net-tools-2.0-0.54.ky10.x86_64.rpm            // 网络工具</span><br><span class="line">        ├── tar-1.32-2.ky10.x86_64.rpm                    // 解压工具</span><br><span class="line">        ├── telnet-0.17-76.ky10.x86_64.rpm                </span><br><span class="line">        └── vim-enhanced-8.2-34.p01.ky10.x86_64.rpm       // 文本编辑器</span><br></pre></td></tr></table></figure>

<h2 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h2><p>将安装包上传到服务器上：</p>
<h3 id="Windows用户操作步骤"><a href="#Windows用户操作步骤" class="headerlink" title="Windows用户操作步骤:"></a>Windows用户操作步骤:</h3><p>使用shell工具和ftp工具（推荐使用<code>Xshell</code>工具和<code>Xftp</code>工具），将文件上传到服务器<code>/</code>目录（由于篇幅有限，关于shell工具及ftp工具的使用，请自行查找资料）</p>
<h3 id="Mac、Linux用户操作步骤，在用户本地电脑执行以下命令："><a href="#Mac、Linux用户操作步骤，在用户本地电脑执行以下命令：" class="headerlink" title="Mac、Linux用户操作步骤，在用户本地电脑执行以下命令："></a>Mac、Linux用户操作步骤，在用户本地电脑执行以下命令：</h3><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">scp -r /cas-relase<span class="number">-2.5</span>-cylin <span class="symbol">root@</span><span class="number">172.16</span><span class="number">.40</span><span class="number">.164</span>:/</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>内容</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>-r</td>
<td>将文件夹内所有内容上传到服务器</td>
</tr>
<tr>
<td>/cas-relase-2.5-cylin</td>
<td>安装包目录位置</td>
</tr>
<tr>
<td>root</td>
<td>服务器登录账户</td>
</tr>
<tr>
<td>172.16.40.164</td>
<td>服务器IP地址</td>
</tr>
<tr>
<td>/</td>
<td>上传到服务器的目录</td>
</tr>
</tbody></table>
<p>之后输入该用户登录密码（Linux系统命令行不会显示你输入的密码，但其实已经输入成功），按Enter键完成输入</p>
<h2 id="安装常用工具"><a href="#安装常用工具" class="headerlink" title="安装常用工具"></a>安装常用工具</h2><blockquote>
<p>若服务器安装操作系统时已经安装下列工具，可跳过此步骤</p>
</blockquote>
<p>进入常用工具文件夹</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">cd <span class="regexp">/data/</span>tools</span><br></pre></td></tr></table></figure>
<p>分别执行以下命令，安装各个工具</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">rpm</span> -ivh tar-<span class="number">1</span>.<span class="number">32</span>-<span class="number">2</span>.ky<span class="number">10</span>.x<span class="number">86</span>_<span class="number">64</span>.rpm</span><br><span class="line"><span class="attribute">rpm</span> -ivh vim-enhanced-<span class="number">8</span>.<span class="number">2</span>-<span class="number">34</span>.p<span class="number">01</span>.ky<span class="number">10</span>.x<span class="number">86</span>_<span class="number">64</span>.rpm</span><br><span class="line"><span class="attribute">rpm</span> -ivh net-tools-<span class="number">2</span>.<span class="number">0</span>-<span class="number">0</span>.<span class="number">54</span>.ky<span class="number">10</span>.x<span class="number">86</span>_<span class="number">64</span>.rpm</span><br><span class="line"><span class="attribute">rpm</span> -ivh telnet-<span class="number">0</span>.<span class="number">17</span>-<span class="number">76</span>.ky<span class="number">10</span>.x<span class="number">86</span>_<span class="number">64</span>.rpm</span><br><span class="line"><span class="attribute">rpm</span> -ivh telnet-<span class="number">0</span>.<span class="number">17</span>-<span class="number">76</span>.ky<span class="number">10</span>.x<span class="number">86</span>_<span class="number">64</span>.rpm</span><br><span class="line"><span class="attribute">rpm</span> -ivh lsof-<span class="number">4</span>.<span class="number">93</span>.<span class="number">2</span>-<span class="number">4</span>.ky<span class="number">10</span>.x<span class="number">86</span>_<span class="number">64</span>.rpm</span><br></pre></td></tr></table></figure>


<h2 id="新建用户"><a href="#新建用户" class="headerlink" title="新建用户"></a>新建用户</h2><h3 id="登录服务器"><a href="#登录服务器" class="headerlink" title="登录服务器"></a>登录服务器</h3><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">ssh <span class="symbol">root@</span><span class="number">172.16</span><span class="number">.40</span><span class="number">.164</span></span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>内容</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>root</td>
<td>服务器登录账户</td>
</tr>
<tr>
<td>172.16.40.164</td>
<td>服务器IP地址</td>
</tr>
</tbody></table>
<p>之后输入该用户登录密码（Linux系统命令行不会显示你输入的密码，但其实已经输入成功），按Enter键完成输入</p>
<h3 id="新建用户-1"><a href="#新建用户-1" class="headerlink" title="新建用户"></a>新建用户</h3><p>添加一个名为comac的用户</p>
<figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">adduser comac</span></span><br></pre></td></tr></table></figure>

<h3 id="修改密码"><a href="#修改密码" class="headerlink" title="修改密码"></a>修改密码</h3><figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">passwd comac</span></span><br></pre></td></tr></table></figure>
<p>根据提示，输入新的密码（Linux系统命令行不会显示你输入的密码）</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">更改用户 comac 的密码 。</span><br><span class="line">新的 密码：<span class="regexp">//</span>在这里输入新密码</span><br><span class="line">重新输入新的 密码：<span class="regexp">//</span>再次输入新密码</span><br><span class="line">passwd：所有的身份验证令牌已经成功更新。</span><br></pre></td></tr></table></figure>

<h3 id="赋予sudo权限"><a href="#赋予sudo权限" class="headerlink" title="赋予sudo权限"></a>赋予sudo权限</h3><p>修改 /etc/sudoers 文件，找到下面一行，在root下面添加一行，如下所示：</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"># Allow root <span class="keyword">to</span> run <span class="keyword">any</span> commands anywhere</span><br><span class="line">root      <span class="keyword">ALL</span>=(<span class="keyword">ALL</span>)     <span class="keyword">ALL</span></span><br><span class="line">comac     <span class="keyword">ALL</span>=(<span class="keyword">ALL</span>)     NOPASSWD:<span class="keyword">ALL</span></span><br></pre></td></tr></table></figure>
<p>以下以vim工具为例（vi/vim工具是Linux系统中最普及、最常用的文本编辑器，由于篇幅有限，不在本文教学，有兴趣可以在网上了解相关资料及教程）</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">vim <span class="regexp">/etc/</span>sudoers</span><br></pre></td></tr></table></figure>
<p>按下<code>i</code>键后进入编辑模式，修改完成后，按下<code>esc</code>键，输入<code>:wq!</code>后，按<code>Enter</code>键保存并退出</p>
<table>
<thead>
<tr>
<th>操作</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>按下<code>i</code>键</td>
<td>进入编辑器的编辑模式</td>
</tr>
<tr>
<td>按下<code>esc</code>键，输入<code>:</code></td>
<td>进入编辑器的指令模式</td>
</tr>
<tr>
<td><code>w</code></td>
<td>保存修改内容</td>
</tr>
<tr>
<td><code>q</code></td>
<td>退出</td>
</tr>
<tr>
<td><code>!</code></td>
<td>强制执行指令</td>
</tr>
</tbody></table>
<h3 id="切换用户"><a href="#切换用户" class="headerlink" title="切换用户"></a>切换用户</h3><figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">su comac</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注：后续操作理论上都应该使用comac用户操作，过高的权限往往伴随着更高的风险，能力越大责任越大</p>
</blockquote>
<h1 id="JDK安装"><a href="#JDK安装" class="headerlink" title="JDK安装"></a>JDK安装</h1><p>执行以下命令进入java文件夹</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">cd <span class="regexp">/data/</span>java</span><br></pre></td></tr></table></figure>

<p>解压jdk压缩包</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">tar</span> -zxvf jdk-<span class="number">8</span>u<span class="number">341</span>-linux-x<span class="number">64</span>.tar.gz</span><br></pre></td></tr></table></figure>

<p>编辑<code>/etc/profile</code>系统配置文件，将jdk添加到环境变量</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">vim <span class="regexp">/etc/</span>profile</span><br></pre></td></tr></table></figure>

<p>按下<code>i</code>键后进入编辑模式，在配置文件末尾加上环境变量配置</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line"><span class="comment"># jdk的解压目录</span></span><br><span class="line"><span class="builtin-name">export</span> <span class="attribute">JAVA_HOME</span>=/data/java/jdk1.8.0_341</span><br><span class="line"><span class="builtin-name">export</span> <span class="attribute">PATH</span>=<span class="variable">$PATH</span>:$JAVA_HOME/bin</span><br></pre></td></tr></table></figure>
<p>修改完成后，按下<code>esc</code>键，输入<code>:wq</code>后，按<code>Enter</code>键保存并退出</p>
<table>
<thead>
<tr>
<th>操作</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>按下<code>i</code>键</td>
<td>进入编辑器的编辑模式</td>
</tr>
<tr>
<td>按下<code>esc</code>键，输入<code>:</code></td>
<td>进入编辑器的指令模式</td>
</tr>
<tr>
<td><code>w</code></td>
<td>保存修改内容</td>
</tr>
<tr>
<td><code>q</code></td>
<td>退出</td>
</tr>
</tbody></table>
<p>刷新配置文件</p>
<figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line"><span class="keyword">source</span> <span class="regexp">/etc/</span>profile</span><br></pre></td></tr></table></figure>

<p>验证</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">java -version</span><br></pre></td></tr></table></figure>
<p>显示jdk版本信息即为成功</p>
<h1 id="Mysql安装"><a href="#Mysql安装" class="headerlink" title="Mysql安装"></a>Mysql安装</h1><p>进入mysql文件夹，解压mysql程序包</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">cd</span> /data/mysql</span><br><span class="line"><span class="attribute">tar</span> -zxvf mysql-<span class="number">5</span>.<span class="number">7</span>.<span class="number">38</span>-<span class="number">1</span>.el<span class="number">7</span>.x<span class="number">86</span>_<span class="number">64</span>.rpm-bundle.tar</span><br></pre></td></tr></table></figure>
<p>解压后依次安装rpm包，由于rpm包有安装顺序，依次按顺序执行安装</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">cd</span> mysql-<span class="number">5</span>.<span class="number">7</span>.<span class="number">38</span>-<span class="number">1</span>.el<span class="number">7</span>.x<span class="number">86</span>_<span class="number">64</span>.rpm-bundle/</span><br><span class="line"><span class="attribute">rpm</span> -ivh mysql-community-common-<span class="number">5</span>.<span class="number">7</span>.<span class="number">38</span>-<span class="number">1</span>.el<span class="number">7</span>.x<span class="number">86</span>_<span class="number">64</span>.rpm</span><br><span class="line"><span class="attribute">rpm</span> -ivh mysql-community-libs-<span class="number">5</span>.<span class="number">7</span>.<span class="number">38</span>-<span class="number">1</span>.el<span class="number">7</span>.x<span class="number">86</span>_<span class="number">64</span>.rpm</span><br><span class="line"><span class="attribute">rpm</span> -ivh mysql-community-client-<span class="number">5</span>.<span class="number">7</span>.<span class="number">38</span>-<span class="number">1</span>.el<span class="number">7</span>.x<span class="number">86</span>_<span class="number">64</span>.rpm</span><br><span class="line"><span class="attribute">rpm</span> -ivh mysql-community-server-<span class="number">5</span>.<span class="number">7</span>.<span class="number">38</span>-<span class="number">1</span>.el<span class="number">7</span>.x<span class="number">86</span>_<span class="number">64</span>.rpm</span><br></pre></td></tr></table></figure>
<p>配置my.cnf，开启表名忽略大小写(如果不需要此功能可以略过此步骤)</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">sudo vim <span class="regexp">/etc/my</span>.cnf</span><br></pre></td></tr></table></figure>

<p>在<code>[mysqld]</code>下面加入：</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="attr">lower_case_table_names</span> = <span class="number">1</span></span><br><span class="line"><span class="attr">default-time_zone</span> = <span class="string">&#x27;+8:00&#x27;</span></span><br></pre></td></tr></table></figure>

<p>启动mysql服务</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">sudo<span class="built_in"> service </span>mysqld start</span><br></pre></td></tr></table></figure>

<p>登陆并修改密码  </p>
<blockquote>
<p>注意：初次安装好mysql server 5.7.x会随机生成root用户的登录密码，在修改root用户密码之前，不能进行任何有效操作，因此，需要使用控制台使用root用户登录并修改密码</p>
</blockquote>
<p>查看随机密码，执行以下命令，命令行会打印出mysql随机生成的root用户的登录密码</p>
<figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line">sudo <span class="keyword">grep</span> <span class="string">&#x27;temporary password&#x27;</span> <span class="regexp">/var/</span>log/mysqld.log</span><br></pre></td></tr></table></figure>
<p>登录mysql</p>
<figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">mysql -uroot -p</span></span><br></pre></td></tr></table></figure>
<p>之后输入该用户登录密码（Linux系统命令行不会显示你输入的密码，但其实已经输入成功），按Enter键完成输入</p>
<p>登录成功后，使用命令修改密码，新密码请使用实际的密码替代：</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">alter<span class="built_in"> user </span>root@localhost identified by <span class="string">&#x27;新密码&#x27;</span>;</span><br><span class="line">flush privileges;</span><br></pre></td></tr></table></figure>

<p>退出mysql</p>
<figure class="highlight cos"><table><tr><td class="code"><pre><span class="line"><span class="keyword">quit</span></span><br></pre></td></tr></table></figure>


<h1 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h1><p>安装</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">cd</span> /data/redis</span><br><span class="line"><span class="attribute">tar</span> -zxvf redis-<span class="number">6</span>.<span class="number">2</span>.<span class="number">7</span>.tar.gz</span><br><span class="line"><span class="attribute">cd</span> /data/redis/redis-<span class="number">6</span>.<span class="number">2</span>.<span class="number">7</span></span><br><span class="line"><span class="attribute">make</span></span><br><span class="line"><span class="attribute">sudo</span> make install</span><br></pre></td></tr></table></figure>




<p>将命令设置为全局</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">ln -s <span class="regexp">/usr/</span>local<span class="regexp">/redis/</span>redis-<span class="number">6.2</span>.<span class="number">7</span><span class="regexp">/src/</span>redis-server <span class="regexp">/usr/</span>bin/redis-server</span><br></pre></td></tr></table></figure>

<p>启动验证</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">sudo redis-server <span class="regexp">/data/</span>redis<span class="regexp">/redis-6.2.7/</span>redis.conf &amp;</span><br></pre></td></tr></table></figure>

<p>Redis配置和启动<br>使用编辑器打开Redis的配置文件（需要root权限，或sudo操作）：/data/redis/redis-6.2.7/redis.conf<br>根据实际情况修改以下内容：</p>
<table>
<thead>
<tr>
<th>修改前</th>
<th>修改后</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>bind 127.0.0.1</code></td>
<td><code># bind 127.0.0.1</code></td>
<td>注释掉该行，取消只从本机访问的限制</td>
</tr>
<tr>
<td><code># requirepass foobared</code></td>
<td><code>requirepass 实际的密码</code></td>
<td>“实际的密码“请根据实际情况进行配置，并取消该行的注释</td>
</tr>
</tbody></table>
<h1 id="Nacos"><a href="#Nacos" class="headerlink" title="Nacos"></a>Nacos</h1><p>解压nacos</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">cd</span> /data/nacos</span><br><span class="line"><span class="attribute">tar</span> -zxvf nacos-server-<span class="number">2</span>.<span class="number">0</span>.<span class="number">3</span>.tar.gz</span><br></pre></td></tr></table></figure>

<p>启动nacos服务</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">// 进入nacos执行程序目录</span><br><span class="line"><span class="built_in">cd</span> /data/nacos/nacos-server-2.0.3/bin</span><br><span class="line"></span><br><span class="line">// 启动</span><br><span class="line">./startup.sh -m standalone &amp;</span><br></pre></td></tr></table></figure>

<p>Nacos的使用</p>
<p>想要登录nacos需要开放服务器防火墙的<code>8848</code>端口，具体操作见防火墙章节</p>
<p>开通<code>8848</code>端口后，在用户本地的浏览器访问<code>http://localhost:8848/nacos</code>，其中<code>localhost</code>请改为实际服务器IP</p>
<p>随后输入账号密码登录<br>默认账号、密码分别为<code>nacos</code>，<code>nacos</code></p>
<h1 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h1><p>安装</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd /data/nginx</span><br><span class="line">tar -zxvf nginx-1.22.0.tar.gz</span><br><span class="line">cd nginx-1.22.0</span><br><span class="line">./configure</span><br><span class="line">make</span><br><span class="line">sudo make install</span><br><span class="line">sudo ln -s /usr/local/nginx/sbin/nginx /usr/bin/nginx</span><br></pre></td></tr></table></figure>

<p>验证，显示nginx的版本号即为成功</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo nginx -v</span><br></pre></td></tr></table></figure>

<p>启动</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo nginx</span><br></pre></td></tr></table></figure>





<h1 id="应用程序安装"><a href="#应用程序安装" class="headerlink" title="应用程序安装"></a>应用程序安装</h1><h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><p>登录mysql</p>
<figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">mysql -uroot -p</span></span><br></pre></td></tr></table></figure>
<p>之后输入该用户登录密码（Linux系统命令行不会显示你输入的密码，但其实已经输入成功），按Enter键完成输入</p>
<p>创建业务数据库</p>
<figure class="highlight n1ql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">schema</span> adms_system <span class="keyword">collate</span> utf8_general_ci;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>操作</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>adms_system</td>
<td>新建数据库名</td>
</tr>
<tr>
<td>utf8_general_ci</td>
<td>数据所用字符集</td>
</tr>
</tbody></table>
<p>切换到新创建的数据库</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> <span class="title">adms_system</span>;</span><br></pre></td></tr></table></figure>

<p>导入业务数据库</p>
<figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line"><span class="keyword">source</span> <span class="regexp">/data/</span>adms<span class="regexp">/server/</span>sql/adms_system.sql;</span><br></pre></td></tr></table></figure>

<p>检查执行结果</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">tables</span>;</span><br></pre></td></tr></table></figure>

<h2 id="后端"><a href="#后端" class="headerlink" title="后端"></a>后端</h2><h3 id="解压压缩文件"><a href="#解压压缩文件" class="headerlink" title="解压压缩文件"></a>解压压缩文件</h3><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">cd /data/adms/server</span><br><span class="line">tar -zxvf server.tar.gz</span><br></pre></td></tr></table></figure>

<h3 id="Nacos配置修改"><a href="#Nacos配置修改" class="headerlink" title="Nacos配置修改"></a>Nacos配置修改</h3><p>登录Nacos后，在<code>配置管理</code>-&gt;<code>配置列表</code>模块中添加3个配置<br>命令|说明<br>-|-<br>adms-system-int.yml|系统核心模块配置<br>adms-gateway-int.yml|网关配置<br>adms-auth-int.yml|权限中心配置</p>
<p>配置具体内容在/adms/server/nacos_config目录下，注意需要根据实际情况修改</p>
<figure class="highlight dts"><table><tr><td class="code"><pre><span class="line"><span class="symbol">redis:</span></span><br><span class="line"><span class="symbol">  host:</span> localhost</span><br><span class="line"><span class="symbol">  port:</span> <span class="number">6379</span></span><br><span class="line"><span class="symbol">  password:</span> <span class="comment">// Redis的实际密码，若未设密码则不填</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight maxima"><table><tr><td class="code"><pre><span class="line">datasource:</span><br><span class="line">  # 主库数据源</span><br><span class="line">  master:</span><br><span class="line">    driver-class-name: com.mysql.cj.jdbc.Driver</span><br><span class="line">    url: jdbc:mysql://localhost:<span class="number">3306</span>/adms_system?useUnicode=<span class="literal">true</span>&amp;characterEncoding=utf8&amp;zeroDateTimeBehavior=convertToNull&amp;useSSL=<span class="literal">true</span>&amp;serverTimezone=GMT%<span class="number">2B8</span></span><br><span class="line">    username: root     // 数据库的登录账户</span><br><span class="line">    password: <span class="number">123456</span>   // 数据库实际密码</span><br></pre></td></tr></table></figure>
<p>其中adms_system改为实际的数据库名</p>
<p>配置格式勾选YAML后发布（三个配置操作相似）</p>
<h3 id="启动应用服务"><a href="#启动应用服务" class="headerlink" title="启动应用服务"></a>启动应用服务</h3><p>启动权限中心服务</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">cd /data/adms/server/auth</span><br><span class="line">nohup java -Xms512m -Xmx1g -XX:<span class="attribute">MetaspaceSize</span>=128m -XX:<span class="attribute">MaxMetaspaceSize</span>=512m -Dfile.<span class="attribute">encoding</span>=utf-8 -Dlog.<span class="attribute">path</span>=./logs -jar cas-auth.jar &gt;/dev/<span class="literal">null</span> 2&gt;&amp;1 &amp;</span><br></pre></td></tr></table></figure>

<p>启动网关服务ww</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">cd /data/adms/server/gateway</span><br><span class="line">nohup java -Xms512m -Xmx1g -XX:<span class="attribute">MetaspaceSize</span>=128m -XX:<span class="attribute">MaxMetaspaceSize</span>=512m -Dfile.<span class="attribute">encoding</span>=utf-8 -Dlog.<span class="attribute">path</span>=./logs -jar cas-gateway.jar &gt;/dev/<span class="literal">null</span> 2&gt;&amp;1 &amp;</span><br></pre></td></tr></table></figure>

<p>启动核心应用服务</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">cd /data/adms/server/system</span><br><span class="line">nohup java -Xms512m -Xmx1g -XX:<span class="attribute">MetaspaceSize</span>=128m -XX:<span class="attribute">MaxMetaspaceSize</span>=512m -Dfile.<span class="attribute">encoding</span>=utf-8 -Dlog.<span class="attribute">path</span>=./logs -jar cas-auth.jar &gt;/dev/<span class="literal">null</span> 2&gt;&amp;1 &amp;</span><br></pre></td></tr></table></figure>


<p>可以登录nacos后在<code>服务管理</code>-&gt;<code>服务列表</code>中查看服务是否启动成功</p>
<h2 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h2><p>解压压缩文件</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">cd <span class="regexp">/data/</span>adms/web</span><br><span class="line">tar -zxvf dist.tar.gz</span><br></pre></td></tr></table></figure>


<p>修改Nginx配置文件</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">vim <span class="regexp">/usr/</span>local<span class="regexp">/nginx/</span>conf/nginx.conf</span><br></pre></td></tr></table></figure>

<p>修改内容如下：</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">listen       <span class="number">28080</span>;                    <span class="regexp">//</span> 浏览器访问的端口</span><br><span class="line"></span><br><span class="line">location / &#123;</span><br><span class="line">    etag   on;</span><br><span class="line">    root   <span class="regexp">/data/</span>adms<span class="regexp">/web/</span>dist;        <span class="regexp">//</span> 前端代码所在目录</span><br><span class="line">    index  index.html index.htm;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="regexp">//</span> 添加以下代理配置</span><br><span class="line">location ^~<span class="regexp">/prod-api/</span> &#123;</span><br><span class="line">    proxy_pass              http:<span class="regexp">//</span><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">8080</span>/;</span><br><span class="line">    proxy_http_version      <span class="number">1.1</span>;</span><br><span class="line">    proxy_set_header        Upgrade         <span class="variable">$http_upgrade</span>;</span><br><span class="line">    proxy_set_header        Connection      <span class="string">&quot;upgrade&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>重写启动Nginx</p>
<figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">sudo nginx -s reload</span></span><br></pre></td></tr></table></figure>


<h1 id="防火墙"><a href="#防火墙" class="headerlink" title="防火墙"></a>防火墙</h1><p>开启防火墙 </p>
<figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">systemctl <span class="literal">start</span> firewalld</span><br></pre></td></tr></table></figure>

<p>开放指定端口</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">firewall-cmd <span class="attribute">--zone</span>=public <span class="attribute">--add-port</span>=1935/tcp --permanent</span><br></pre></td></tr></table></figure>
<p>命令含义：<br>–zone #作用域<br>–add-port=1935/tcp  #添加端口，格式为：端口/通讯协议<br>–permanent  #永久生效，没有此参数重启后失效  </p>
<p>重启防火墙</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line">firewall-<span class="keyword">cmd</span><span class="bash"> --reload</span></span><br></pre></td></tr></table></figure>
<p>查看端口号</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line"><span class="regexp">//</span>查看当前所有tcp端口</span><br><span class="line"></span><br><span class="line">netstat -ntlp</span><br><span class="line"></span><br><span class="line"><span class="regexp">//</span>查看所有<span class="number">1935</span>端口使用情况</span><br><span class="line"></span><br><span class="line">netstat -ntulp |grep <span class="number">1935</span></span><br></pre></td></tr></table></figure>




<h1 id="Linux系统的一些常用命令"><a href="#Linux系统的一些常用命令" class="headerlink" title="Linux系统的一些常用命令"></a>Linux系统的一些常用命令</h1><table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>ls</code></td>
<td>打印当前目录的文件及文件夹</td>
</tr>
<tr>
<td><code>ll</code></td>
<td><code>ls</code>的进阶版，相当于<code>ls -l</code>，可以打印文件及文件夹的详细信息</td>
</tr>
<tr>
<td><code>pwd</code></td>
<td>打印当前所在的目录</td>
</tr>
<tr>
<td><code>cd</code></td>
<td>例<code>cd /data</code>会进入<code>/data</code>目录，其中<code>/data</code>可以改为任意目录，以/开头的目录为绝对目录（会进入根目录的data文件夹），若要进入当前文件夹下的data目录命令<code>cd data</code>；<code>cd ..</code>会返回上一级目录</td>
</tr>
</tbody></table>
]]></content>
      <tags>
        <tag>应用部署</tag>
      </tags>
  </entry>
  <entry>
    <title>EICD系统服务器部署文档（CentOS离线安装）</title>
    <url>/2022/08/31/EICD%E7%B3%BB%E7%BB%9F%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%83%A8%E7%BD%B2%E6%96%87%E6%A1%A3%EF%BC%88CentOS%E7%A6%BB%E7%BA%BF%E5%AE%89%E8%A3%85%EF%BC%89/</url>
    <content><![CDATA[<h1 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h1><h2 id="安装包明细"><a href="#安装包明细" class="headerlink" title="安装包明细"></a>安装包明细</h2><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">data</span><br><span class="line">  ├── java                                                </span><br><span class="line">  │     └── jdk-8u341-linux-x64.tar.gz                    // jdk压缩包</span><br><span class="line">  │</span><br><span class="line">  ├── mysql                                               </span><br><span class="line">  │     └── mysql-5.7.38-1.el7.x86_64.rpm-bundle.tar      // Mysql数据库程序包</span><br><span class="line">  │</span><br><span class="line">  ├── nacos                                               </span><br><span class="line">  │     └── nacos-server-2.0.3.tar.gz                     // Nacos程序包</span><br><span class="line">  │</span><br><span class="line">  ├── nginx                                               </span><br><span class="line">  │     └── nginx-1.22.0.tar.gz                           // Nginx程序包</span><br><span class="line">  │</span><br><span class="line">  ├── redis                                               </span><br><span class="line">  │     └── redis-6.2.7.tar.gz                            // Redis程序包</span><br><span class="line">  │</span><br><span class="line">  └── tools</span><br><span class="line">        ├── lsof-4.93.2-4.ky10.x86_64.rpm                 </span><br><span class="line">        ├── net-tools-2.0-0.54.ky10.x86_64.rpm            // 网络工具</span><br><span class="line">        ├── tar-1.32-2.ky10.x86_64.rpm                    // 解压工具</span><br><span class="line">        ├── telnet-0.17-76.ky10.x86_64.rpm                </span><br><span class="line">        └── vim-enhanced-8.2-34.p01.ky10.x86_64.rpm       // 文本编辑器</span><br></pre></td></tr></table></figure>

<h2 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h2><p>将安装包上传到服务器上：</p>
<h3 id="Windows用户操作步骤"><a href="#Windows用户操作步骤" class="headerlink" title="Windows用户操作步骤:"></a>Windows用户操作步骤:</h3><p>使用shell工具和ftp工具（推荐使用<code>Xshell</code>工具和<code>Xftp</code>工具），将文件上传到服务器<code>/</code>目录（由于篇幅有限，关于shell工具及ftp工具的使用，请自行查找资料）</p>
<h3 id="Mac、Linux用户操作步骤，在用户本地电脑执行以下命令："><a href="#Mac、Linux用户操作步骤，在用户本地电脑执行以下命令：" class="headerlink" title="Mac、Linux用户操作步骤，在用户本地电脑执行以下命令："></a>Mac、Linux用户操作步骤，在用户本地电脑执行以下命令：</h3><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">scp -r /data <span class="symbol">root@</span><span class="number">172.16</span><span class="number">.40</span><span class="number">.164</span>:/</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>内容</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>-r</td>
<td>将文件夹内所有内容上传到服务器</td>
</tr>
<tr>
<td>/data</td>
<td>安装包目录位置</td>
</tr>
<tr>
<td>root</td>
<td>服务器登录账户</td>
</tr>
<tr>
<td>172.16.40.164</td>
<td>服务器IP地址</td>
</tr>
<tr>
<td>/</td>
<td>上传到服务器的目录</td>
</tr>
</tbody></table>
<p>之后输入该用户登录密码（Linux系统命令行不会显示你输入的密码，但其实已经输入成功），按Enter键完成输入</p>
<h2 id="安装常用工具"><a href="#安装常用工具" class="headerlink" title="安装常用工具"></a>安装常用工具</h2><blockquote>
<p>若服务器安装操作系统时已经安装下列工具，可跳过此步骤</p>
</blockquote>
<p>进入常用工具文件夹</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">cd <span class="regexp">/data/</span>tools</span><br></pre></td></tr></table></figure>
<p>分别执行以下命令，安装各个工具</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">rpm</span> -ivh tar-<span class="number">1</span>.<span class="number">32</span>-<span class="number">2</span>.ky<span class="number">10</span>.x<span class="number">86</span>_<span class="number">64</span>.rpm</span><br><span class="line"><span class="attribute">rpm</span> -ivh vim-enhanced-<span class="number">8</span>.<span class="number">2</span>-<span class="number">34</span>.p<span class="number">01</span>.ky<span class="number">10</span>.x<span class="number">86</span>_<span class="number">64</span>.rpm</span><br><span class="line"><span class="attribute">rpm</span> -ivh net-tools-<span class="number">2</span>.<span class="number">0</span>-<span class="number">0</span>.<span class="number">54</span>.ky<span class="number">10</span>.x<span class="number">86</span>_<span class="number">64</span>.rpm</span><br><span class="line"><span class="attribute">rpm</span> -ivh telnet-<span class="number">0</span>.<span class="number">17</span>-<span class="number">76</span>.ky<span class="number">10</span>.x<span class="number">86</span>_<span class="number">64</span>.rpm</span><br><span class="line"><span class="attribute">rpm</span> -ivh telnet-<span class="number">0</span>.<span class="number">17</span>-<span class="number">76</span>.ky<span class="number">10</span>.x<span class="number">86</span>_<span class="number">64</span>.rpm</span><br><span class="line"><span class="attribute">rpm</span> -ivh lsof-<span class="number">4</span>.<span class="number">93</span>.<span class="number">2</span>-<span class="number">4</span>.ky<span class="number">10</span>.x<span class="number">86</span>_<span class="number">64</span>.rpm</span><br></pre></td></tr></table></figure>


<h2 id="新建用户"><a href="#新建用户" class="headerlink" title="新建用户"></a>新建用户</h2><h3 id="登录服务器"><a href="#登录服务器" class="headerlink" title="登录服务器"></a>登录服务器</h3><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">ssh <span class="symbol">root@</span><span class="number">172.16</span><span class="number">.40</span><span class="number">.164</span></span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>内容</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>root</td>
<td>服务器登录账户</td>
</tr>
<tr>
<td>172.16.40.164</td>
<td>服务器IP地址</td>
</tr>
</tbody></table>
<p>之后输入该用户登录密码（Linux系统命令行不会显示你输入的密码，但其实已经输入成功），按Enter键完成输入</p>
<h3 id="新建用户-1"><a href="#新建用户-1" class="headerlink" title="新建用户"></a>新建用户</h3><p>添加一个名为comac的用户</p>
<figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">adduser comac</span></span><br></pre></td></tr></table></figure>

<h3 id="修改密码"><a href="#修改密码" class="headerlink" title="修改密码"></a>修改密码</h3><figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">passwd comac</span></span><br></pre></td></tr></table></figure>
<p>根据提示，输入新的密码（Linux系统命令行不会显示你输入的密码）</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">更改用户 comac 的密码 。</span><br><span class="line">新的 密码：<span class="regexp">//</span>在这里输入新密码</span><br><span class="line">重新输入新的 密码：<span class="regexp">//</span>再次输入新密码</span><br><span class="line">passwd：所有的身份验证令牌已经成功更新。</span><br></pre></td></tr></table></figure>

<h3 id="赋予sudo权限"><a href="#赋予sudo权限" class="headerlink" title="赋予sudo权限"></a>赋予sudo权限</h3><p>修改 /etc/sudoers 文件，找到下面一行，在root下面添加一行，如下所示：</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"># Allow root <span class="keyword">to</span> run <span class="keyword">any</span> commands anywhere</span><br><span class="line">root      <span class="keyword">ALL</span>=(<span class="keyword">ALL</span>)     <span class="keyword">ALL</span></span><br><span class="line">comac     <span class="keyword">ALL</span>=(<span class="keyword">ALL</span>)     NOPASSWD:<span class="keyword">ALL</span></span><br></pre></td></tr></table></figure>
<p>以下以vim工具为例（vi/vim工具是Linux系统中最普及、最常用的文本编辑器，由于篇幅有限，不在本文教学，有兴趣可以在网上了解相关资料及教程）</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">vim <span class="regexp">/etc/</span>sudoers</span><br></pre></td></tr></table></figure>
<p>按下<code>i</code>键后进入编辑模式，修改完成后，按下<code>esc</code>键，输入<code>:wq!</code>后，按<code>Enter</code>键保存并退出</p>
<table>
<thead>
<tr>
<th>操作</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>按下<code>i</code>键</td>
<td>进入编辑器的编辑模式</td>
</tr>
<tr>
<td>按下<code>esc</code>键，输入<code>:</code></td>
<td>进入编辑器的指令模式</td>
</tr>
<tr>
<td><code>w</code></td>
<td>保存修改内容</td>
</tr>
<tr>
<td><code>q</code></td>
<td>退出</td>
</tr>
<tr>
<td><code>!</code></td>
<td>强制执行指令</td>
</tr>
</tbody></table>
<h3 id="切换用户"><a href="#切换用户" class="headerlink" title="切换用户"></a>切换用户</h3><figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">su comac</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注：后续操作理论上都应该使用comac用户操作，过高的权限往往便随着更高的风险，能力越大责任越大</p>
</blockquote>
<h1 id="JDK安装"><a href="#JDK安装" class="headerlink" title="JDK安装"></a>JDK安装</h1><p>执行以下命令进入java文件夹</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">cd <span class="regexp">/data/</span>java</span><br></pre></td></tr></table></figure>

<p>解压jdk压缩包</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">tar</span> -zxvf jdk-<span class="number">8</span>u<span class="number">341</span>-linux-x<span class="number">64</span>.tar.gz</span><br></pre></td></tr></table></figure>

<p>编辑<code>/etc/profile</code>系统配置文件，将jdk添加到环境变量</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">vim <span class="regexp">/etc/</span>profile</span><br></pre></td></tr></table></figure>

<p>按下<code>i</code>键后进入编辑模式，在配置文件末尾加上环境变量配置</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line"><span class="comment"># jdk的解压目录</span></span><br><span class="line"><span class="builtin-name">export</span> <span class="attribute">JAVA_HOME</span>=/data/java/jdk1.8.0_341</span><br><span class="line"><span class="builtin-name">export</span> <span class="attribute">PATH</span>=<span class="variable">$PATH</span>:$JAVA_HOME/bin</span><br></pre></td></tr></table></figure>
<p>修改完成后，按下<code>esc</code>键，输入<code>:wq</code>后，按<code>Enter</code>键保存并退出</p>
<table>
<thead>
<tr>
<th>操作</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>按下<code>i</code>键</td>
<td>进入编辑器的编辑模式</td>
</tr>
<tr>
<td>按下<code>esc</code>键，输入<code>:</code></td>
<td>进入编辑器的指令模式</td>
</tr>
<tr>
<td><code>w</code></td>
<td>保存修改内容</td>
</tr>
<tr>
<td><code>q</code></td>
<td>退出</td>
</tr>
</tbody></table>
<p>刷新配置文件</p>
<figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line"><span class="keyword">source</span> <span class="regexp">/etc/</span>profile</span><br></pre></td></tr></table></figure>

<p>验证</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">java -version</span><br></pre></td></tr></table></figure>
<p>显示jdk版本信息即为成功</p>
<h1 id="Mysql安装"><a href="#Mysql安装" class="headerlink" title="Mysql安装"></a>Mysql安装</h1><p>进入mysql文件夹，解压mysql程序包</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">cd</span> /data/mysql</span><br><span class="line"><span class="attribute">tar</span> -zxvf mysql-<span class="number">5</span>.<span class="number">7</span>.<span class="number">38</span>-<span class="number">1</span>.el<span class="number">7</span>.x<span class="number">86</span>_<span class="number">64</span>.rpm-bundle.tar</span><br></pre></td></tr></table></figure>
<p>解压后依次安装rpm包，由于rpm包有安装顺序，依次按顺序执行安装</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">cd</span> mysql-<span class="number">5</span>.<span class="number">7</span>.<span class="number">38</span>-<span class="number">1</span>.el<span class="number">7</span>.x<span class="number">86</span>_<span class="number">64</span>.rpm-bundle/</span><br><span class="line"><span class="attribute">rpm</span> -ivh mysql-community-common-<span class="number">5</span>.<span class="number">7</span>.<span class="number">38</span>-<span class="number">1</span>.el<span class="number">7</span>.x<span class="number">86</span>_<span class="number">64</span>.rpm</span><br><span class="line"><span class="attribute">rpm</span> -ivh mysql-community-libs-<span class="number">5</span>.<span class="number">7</span>.<span class="number">38</span>-<span class="number">1</span>.el<span class="number">7</span>.x<span class="number">86</span>_<span class="number">64</span>.rpm</span><br><span class="line"><span class="attribute">rpm</span> -ivh mysql-community-client-<span class="number">5</span>.<span class="number">7</span>.<span class="number">38</span>-<span class="number">1</span>.el<span class="number">7</span>.x<span class="number">86</span>_<span class="number">64</span>.rpm</span><br><span class="line"><span class="attribute">rpm</span> -ivh mysql-community-server-<span class="number">5</span>.<span class="number">7</span>.<span class="number">38</span>-<span class="number">1</span>.el<span class="number">7</span>.x<span class="number">86</span>_<span class="number">64</span>.rpm</span><br></pre></td></tr></table></figure>
<p>配置my.cnf，开启表名忽略大小写(如果不需要此功能可以略过此步骤)</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">sudo vim <span class="regexp">/etc/my</span>.cnf</span><br></pre></td></tr></table></figure>

<p>在<code>[mysqld]</code>下面加入：</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="attr">lower_case_table_names</span>=<span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>启动mysql服务</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">sudo<span class="built_in"> service </span>mysqld start</span><br></pre></td></tr></table></figure>

<p>登陆并修改密码  </p>
<blockquote>
<p>注意：初次安装好mysql server 5.7.x会随机生成root用户的登录密码，在修改root用户密码之前，不能进行任何有效操作，因此，需要使用控制台使用root用户登录并修改密码</p>
</blockquote>
<p>查看随机密码，执行以下命令，命令行会打印出mysql随机生成的root用户的登录密码</p>
<figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line">sudo <span class="keyword">grep</span> <span class="string">&#x27;temporary password&#x27;</span> <span class="regexp">/var/</span>log/mysqld.log</span><br></pre></td></tr></table></figure>
<p>登录mysql</p>
<figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">mysql -uroot -p</span></span><br></pre></td></tr></table></figure>
<p>之后输入该用户登录密码（Linux系统命令行不会显示你输入的密码，但其实已经输入成功），按Enter键完成输入</p>
<p>登录成功后，使用命令修改密码，新密码请使用实际的密码替代：</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">alter<span class="built_in"> user </span>root@localhost identified by <span class="string">&#x27;新密码&#x27;</span>;</span><br><span class="line">flush privileges;</span><br></pre></td></tr></table></figure>

<p>退出mysql</p>
<figure class="highlight cos"><table><tr><td class="code"><pre><span class="line"><span class="keyword">quit</span></span><br></pre></td></tr></table></figure>


<h1 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h1><p>安装</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">cd</span> /data/redis</span><br><span class="line"><span class="attribute">tar</span> -zxvf redis-<span class="number">6</span>.<span class="number">2</span>.<span class="number">7</span>.tar.gz</span><br><span class="line"><span class="attribute">cd</span> /data/redis/redis-<span class="number">6</span>.<span class="number">2</span>.<span class="number">7</span></span><br><span class="line"><span class="attribute">make</span></span><br><span class="line"><span class="attribute">sudo</span> make install</span><br></pre></td></tr></table></figure>




<p>将命令设置为全局</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">ln -s <span class="regexp">/usr/</span>local<span class="regexp">/redis/</span>redis-<span class="number">6.2</span>.<span class="number">7</span><span class="regexp">/src/</span>redis-server <span class="regexp">/usr/</span>bin/redis-server</span><br></pre></td></tr></table></figure>

<p>启动验证</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">sudo redis-server <span class="regexp">/data/</span>redis<span class="regexp">/redis-6.2.7/</span>redis.conf &amp;</span><br></pre></td></tr></table></figure>

<p>Redis配置和启动<br>使用编辑器打开Redis的配置文件（需要root权限，或sudo操作）：/data/redis/redis-6.2.7/redis.conf<br>根据实际情况修改以下内容：</p>
<table>
<thead>
<tr>
<th>修改前</th>
<th>修改后</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>bind 127.0.0.1</code></td>
<td><code># bind 127.0.0.1</code></td>
<td>注释掉该行，取消只从本机访问的限制</td>
</tr>
<tr>
<td><code># requirepass foobared</code></td>
<td><code>requirepass 实际的密码</code></td>
<td>“实际的密码“请根据实际情况进行配置，并取消该行的注释</td>
</tr>
</tbody></table>
<h1 id="Nacos"><a href="#Nacos" class="headerlink" title="Nacos"></a>Nacos</h1><p>解压nacos</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">cd</span> /data/nacos</span><br><span class="line"><span class="attribute">tar</span> -zxvf nacos-server-<span class="number">2</span>.<span class="number">0</span>.<span class="number">3</span>.tar.gz</span><br></pre></td></tr></table></figure>

<p>启动nacos服务</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">// 进入nacos执行程序目录</span><br><span class="line"><span class="built_in">cd</span> /data/nacos/nacos-server-2.0.3/bin</span><br><span class="line"></span><br><span class="line">// 启动</span><br><span class="line">./startup.sh -m standalone &amp;</span><br></pre></td></tr></table></figure>

<p>Nacos的使用</p>
<p>想要登录nacos需要开放服务器防火墙的<code>8848</code>端口，具体操作见防火墙章节</p>
<p>开通<code>8848</code>端口后，在用户本地的浏览器访问<code>http://localhost:8848/nacos</code>，其中<code>localhost</code>请改为实际服务器IP</p>
<p>随后输入账号密码登录<br>默认账号、密码分别为<code>nacos</code>，<code>nacos</code></p>
<h1 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h1><p>安装</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd /data/nginx</span><br><span class="line">tar -zxvf nginx-1.22.0.tar.gz</span><br><span class="line">cd nginx-1.22.0</span><br><span class="line">./configure</span><br><span class="line">make</span><br><span class="line">sudo make install</span><br><span class="line">sudo ln -s /usr/local/nginx/sbin/nginx /usr/bin/nginx</span><br></pre></td></tr></table></figure>

<p>验证，显示nginx的版本号即为成功</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo nginx -v</span><br></pre></td></tr></table></figure>

<p>启动</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo nginx</span><br></pre></td></tr></table></figure>





<h1 id="应用程序安装"><a href="#应用程序安装" class="headerlink" title="应用程序安装"></a>应用程序安装</h1><h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><p>登录mysql</p>
<figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">mysql -uroot -p</span></span><br></pre></td></tr></table></figure>
<p>之后输入该用户登录密码（Linux系统命令行不会显示你输入的密码，但其实已经输入成功），按Enter键完成输入</p>
<p>创建业务数据库</p>
<figure class="highlight n1ql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">schema</span> eicd_system <span class="keyword">collate</span> utf8_general_ci;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>操作</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>eicd_system</td>
<td>新建数据库名</td>
</tr>
<tr>
<td>utf8_general_ci</td>
<td>数据所用字符集</td>
</tr>
</tbody></table>
<p>切换到新创建的数据库</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> <span class="title">eicd_system</span>;</span><br></pre></td></tr></table></figure>

<p>导入业务数据库</p>
<figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line"><span class="keyword">source</span> <span class="regexp">/data/</span>eicd<span class="regexp">/server/</span>sql/eicd_system.sql;</span><br></pre></td></tr></table></figure>

<p>检查执行结果</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">tables</span>;</span><br></pre></td></tr></table></figure>

<h2 id="后端"><a href="#后端" class="headerlink" title="后端"></a>后端</h2><h3 id="Nacos配置修改"><a href="#Nacos配置修改" class="headerlink" title="Nacos配置修改"></a>Nacos配置修改</h3><p>登录Nacos后，在<code>配置管理</code>-&gt;<code>配置列表</code>模块中添加配置</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>eicd-service-dev.yml</td>
<td>系统核心模块配置</td>
</tr>
</tbody></table>
<!-- eicd-gateway-int.yml|网关配置 -->
<!-- eicd-auth-int.yml|权限中心配置 -->

<p>配置具体内容在/eicd/server/nacos_config目录下，注意需要根据实际情况修改</p>
<figure class="highlight dts"><table><tr><td class="code"><pre><span class="line"><span class="symbol">redis:</span></span><br><span class="line"><span class="symbol">  host:</span> localhost</span><br><span class="line"><span class="symbol">  port:</span> <span class="number">6379</span></span><br><span class="line"><span class="symbol">  password:</span> <span class="comment">// Redis的实际密码，若未设密码则不填</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight maxima"><table><tr><td class="code"><pre><span class="line">datasource:</span><br><span class="line">  # 主库数据源</span><br><span class="line">  master:</span><br><span class="line">    driver-class-name: com.mysql.cj.jdbc.Driver</span><br><span class="line">    url: jdbc:mysql://localhost:<span class="number">3306</span>/eicd_system?useUnicode=<span class="literal">true</span>&amp;characterEncoding=utf8&amp;zeroDateTimeBehavior=convertToNull&amp;useSSL=<span class="literal">true</span>&amp;serverTimezone=GMT%<span class="number">2B8</span></span><br><span class="line">    username: root     // 数据库的登录账户</span><br><span class="line">    password: <span class="number">123456</span>   // 数据库实际密码</span><br></pre></td></tr></table></figure>
<p>其中eicd_system改为实际的数据库名</p>
<p>配置格式勾选YAML后发布</p>
<h3 id="启动应用服务"><a href="#启动应用服务" class="headerlink" title="启动应用服务"></a>启动应用服务</h3><blockquote>
<p>后端引用服务使用maven打包，Maven官网下载对应版本的bin包：<a href="https://maven.apache.org/download.cgi%EF%BC%8C%E6%8E%A8%E8%8D%903.6.3%E7%89%88%E6%9C%AC">https://maven.apache.org/download.cgi，推荐3.6.3版本</a><br>将包上传至服务器<code>/data/eicd/server/system</code>目录</p>
</blockquote>
<p>启动核心应用服务</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">cd /data/eicd/server/system</span><br><span class="line">nohup java -Xms512m -Xmx1g -XX:<span class="attribute">MetaspaceSize</span>=128m -XX:<span class="attribute">MaxMetaspaceSize</span>=512m -Dfile.<span class="attribute">encoding</span>=utf-8 -Dlog.<span class="attribute">path</span>=./logs -jar eicd-service-1.0-SNAPSHOT-exe.jar &gt;/dev/<span class="literal">null</span> 2&gt;&amp;1 &amp;</span><br></pre></td></tr></table></figure>


<table>
<thead>
<tr>
<th>内容</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>nohup java</td>
<td>后台启动java程序</td>
</tr>
<tr>
<td>-Xms512m -Xmx1g -XX:MetaspaceSize=128m -XX:MaxMetaspaceSize=512m -Dfile.encoding=utf-8 -Dlog.path=./logs</td>
<td>jvm启动参数</td>
</tr>
<tr>
<td>-jar</td>
<td>以jar包形式启动</td>
</tr>
<tr>
<td>eicd-service-1.0-SNAPSHOT-exe.jar</td>
<td>应用程序打包文件名称，以实际为准</td>
</tr>
<tr>
<td>&gt;/dev/null 2&gt;&amp;1 &amp;</td>
<td>关闭程序运行中的内容输出</td>
</tr>
</tbody></table>
<p>可以登录nacos后在<code>服务管理</code>-&gt;<code>服务列表</code>中查看服务是否启动成功</p>
<h2 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h2><blockquote>
<p>通过node.js将前端程序打包<br>将包上传至服务器<code>/data/eicd/web</code>目录</p>
</blockquote>
<p>修改Nginx配置文件</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">vim <span class="regexp">/usr/</span>local<span class="regexp">/nginx/</span>conf/nginx.conf</span><br></pre></td></tr></table></figure>

<p>修改内容如下：</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">listen       <span class="number">80</span>;                       <span class="regexp">//</span> 浏览器访问的端口</span><br><span class="line"></span><br><span class="line">upstream eicd_server &#123;</span><br><span class="line">    server localhost:<span class="number">18081</span>;</span><br><span class="line">    ip_hash;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">location / &#123;</span><br><span class="line">    root   <span class="regexp">/data/</span>eicd<span class="regexp">/web/</span>dist;        <span class="regexp">//</span> 前端代码所在目录</span><br><span class="line">    index  index.html index.htm;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="regexp">//</span> 添加以下代理配置</span><br><span class="line">location ^~<span class="regexp">/prod-api/</span> &#123;</span><br><span class="line">    proxy_pass              http:<span class="regexp">//</span><span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">8080</span>/;</span><br><span class="line">    proxy_http_version      <span class="number">1.1</span>;</span><br><span class="line">    proxy_set_header        Upgrade         <span class="variable">$http_upgrade</span>;</span><br><span class="line">    proxy_set_header        Connection      <span class="string">&quot;upgrade&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>重写启动Nginx</p>
<figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">sudo nginx -s reload</span></span><br></pre></td></tr></table></figure>


<h1 id="防火墙"><a href="#防火墙" class="headerlink" title="防火墙"></a>防火墙</h1><p>开启防火墙 </p>
<figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">systemctl <span class="literal">start</span> firewalld</span><br></pre></td></tr></table></figure>

<p>开放指定端口</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">firewall-cmd <span class="attribute">--zone</span>=public <span class="attribute">--add-port</span>=80/tcp --permanent</span><br></pre></td></tr></table></figure>
<p>命令含义：<br>–zone #作用域<br>–add-port=80/tcp  #添加端口，格式为：端口/通讯协议<br>–permanent  #永久生效，没有此参数重启后失效  </p>
<p>重启防火墙</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line">firewall-<span class="keyword">cmd</span><span class="bash"> --reload</span></span><br></pre></td></tr></table></figure>
<p>查看端口号</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line"><span class="regexp">//</span>查看当前所有tcp端口</span><br><span class="line"></span><br><span class="line">netstat -ntlp</span><br><span class="line"></span><br><span class="line"><span class="regexp">//</span>查看所有<span class="number">1935</span>端口使用情况</span><br><span class="line">netstat -ntulp |grep <span class="number">80</span></span><br></pre></td></tr></table></figure>




<h1 id="Linux系统的一些常用命令"><a href="#Linux系统的一些常用命令" class="headerlink" title="Linux系统的一些常用命令"></a>Linux系统的一些常用命令</h1><table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>ls</code></td>
<td>打印当前目录的文件及文件夹</td>
</tr>
<tr>
<td><code>ll</code></td>
<td><code>ls</code>的进阶版，相当于<code>ls -l</code>，可以打印文件及文件夹的详细信息</td>
</tr>
<tr>
<td><code>pwd</code></td>
<td>打印当前所在的目录</td>
</tr>
<tr>
<td><code>cd</code></td>
<td>例<code>cd /data</code>会进入<code>/data</code>目录，其中<code>/data</code>可以改为任意目录，以/开头的目录为绝对目录（会进入根目录的data文件夹），若要进入当前文件夹下的data目录命令<code>cd data</code>；<code>cd ..</code>会返回上一级目录</td>
</tr>
</tbody></table>
]]></content>
      <tags>
        <tag>应用部署</tag>
      </tags>
  </entry>
</search>
