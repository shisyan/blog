<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Java8新特性</title>
    <url>/2020/10/27/Java8%E6%96%B0%E7%89%B9%E6%80%A7/</url>
    <content><![CDATA[<p>毫无疑问，Java 8是自Java  5（2004年）发布以来Java语言最大的一次版本升级，Java 8带来了很多的新特性，比如编译器、类库、开发工具和JVM（Java虚拟机）。在这篇教程中我们将会学习这些新特性，并通过真实例子演示说明它们适用的场景。</p>
<h1 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h1><p>在JDK8之前，一个方法能接受的参数都是变量，例如： object.method(Object o)<br>那么，如果需要传入一个动作呢？比如回调。<br>那么你可能会想到匿名内部类。<br>例如：<br>匿名内部类是需要依赖接口的，所以需要先定义个接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">PersonCallback</span> </span>&#123;</span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">callback</span><span class="params">(Person person)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Person类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(<span class="keyword">int</span> id, String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 创建一个person后，进行回调</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">create</span><span class="params">(Integer id, String name, PersonCallback personCallback)</span> </span>&#123;</span><br><span class="line">        Person person = <span class="keyword">new</span> Person(id, name);</span><br><span class="line">        personCallback.callback(person);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Person.create(<span class="number">1</span>, <span class="string">&quot;张三&quot;</span>, <span class="keyword">new</span> PersonCallback() &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">callback</span><span class="params">(Person person)</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;去注册...&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    Person.create(<span class="number">2</span>, <span class="string">&quot;老师&quot;</span>, <span class="keyword">new</span> PersonCallback() &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">callback</span><span class="params">(Person person)</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;去登陆...&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>上面的PersonCallback其实就是一种动作，但是我们真正关心的只有callback方法里的内容而已，我们用Lambda<br>表示，可以将上面的代码就可以优化成：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Person.create(<span class="number">1</span>, <span class="string">&quot;张三&quot;</span>, (Person person) -&gt; &#123;System.out.println(<span class="string">&quot;去登陆...&quot;</span>);&#125;)</span><br></pre></td></tr></table></figure>
<p>有没有发现特别简单了…，但是我们发现Person.create这个方法其实接收的对象依然是PersonCallback这个接<br>口，但是现在传的是一个Lambda表达式，那么难道Lambda表达式也实现了这个接口？问题也放这，我们<br>先看一下Lambda表达式的接口。<br>Lambda允许把函数作为一个方法的参数，一个lambda由用逗号分隔的<code>参数列表</code>、<code>–&gt;</code>、<code>函数体</code>三部分表<br>示。对于上面的表达式</p>
<ol>
<li><code>(Person person)</code>为Lambda表达式的入参，<code>&#123;System.out.println(&quot;去注册...&quot;);&#125;</code>为函数体</li>
<li>重点是这个表达式是没有名字的。</li>
</ol>
<p>我们知道，当我们实现一个接口的时候，肯定要实现接口里面的方法，那么现在一个Lambda表达式应该也要遵<br>循这一个基本准则，那么一个Lambda表达式它实现了接口里的什么方法呢？<br>答案是：一个Lambda表达式实现了接口里的有且仅有的唯一一个抽象方法。那么对于这种接口就叫做<strong>函数式接口</strong>。<br>Lambda表达式其实完成了<strong>实现接口并且实现接口里的方法</strong>这一功能，也可以认为Lambda表达式代表一种<strong>动作</strong>，我们可以直接把这种特殊的动作进行传递。<br>当然，对于上面的Lambda表达式你可以简化：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Person.create(<span class="number">1</span>, <span class="string">&quot;张三&quot;</span>, person -&gt; System.out.println(<span class="string">&quot;去登陆...&quot;</span>));</span><br></pre></td></tr></table></figure>
<p>这归功于Java8的类型推导机制。因为现在接口里只有一个方法，那么现在这个Lambda表达式肯定是对应实现了<br>这个方法，既然是唯一的对应关系，那么入参肯定是Person类，所以可以简写，并且方法体只有唯一的一条语<br>句，所以也可以简写，以达到表达式简洁的效果。</p>
<h1 id="函数式接口"><a href="#函数式接口" class="headerlink" title="函数式接口"></a>函数式接口</h1><p>函数式接口是新增的一种接口定义。</p>
<p>用<code>@FunctionalInterface</code>修饰的接口叫做函数式接口，或者，函数式接口就是一个<strong>只具有一个抽象方法的普通接口</strong>，<code>@FunctionalInterface</code>可以起到校验的作用。<br>下面的接口只有一个抽象方法能编译正确：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TestFunctionalInterface</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面的接口有多个抽象方法会编译错误：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TestFunctionalInterface</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在JDK7中其实就已经有一些函数式接口了，比如Runnable、Callable、FileFilter等等。<br>在JDK8中也增加了很多函数式接口，比如java.util.function包。<br>比如这四个常用的接口：</p>
<table>
<thead>
<tr>
<th>接口</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>Supplier</td>
<td>无参数，返回一个结果</td>
</tr>
<tr>
<td>Function</td>
<td>接受一个输入参数，返回一个结果</td>
</tr>
<tr>
<td>Consumer</td>
<td>接受一个输入参数，无返回结果</td>
</tr>
<tr>
<td>Predicate</td>
<td>接受一个输入参数，返回一个布尔值结果</td>
</tr>
</tbody></table>
<p>那么Java8中给我们加了这么多函数式接口有什么作用？<br>上文我们分析到，一个Lambda表达式其实也可以理解为一个函数式接口的实现者，但是作为表达式，它的写法<br>其实是多种多样的，比如</p>
<ul>
<li>() -&gt; {return 0;}，没有传入参数，有返回值</li>
<li>(int i) -&gt; {return 0;}，传入一个参数，有返回值</li>
<li>(int i) -&gt; {System.out.println(i)}，传入一个int类型的参数，但是没有返回值</li>
<li>(int i, int j) -&gt; {System.out.println(i)}，传入两个int类型的参数，但是没有返回值</li>
<li>(int i, int j) -&gt; {return i+j;}，传入两个int类型的参数，返回一个int值</li>
<li>(int i, int j) -&gt; {return i&gt;j;}，传入两个int类型的参数，返回一个boolean值</li>
</ul>
<p>还有许多许多种情况,那么这每种表达式的写法其实都应该是某个函数式接口的实现类，需要特定<br>函数式接口进行对应，比如上面的四种情况就分别对应<code>Supplier&lt;T&gt;</code>，<code>Function&lt;T,R&gt;</code>， <code>Consumer&lt;T&gt;</code>，<code>BiConsumer&lt;T,U&gt;</code>，<code>BiFunction&lt;T,U,R&gt;</code>，<code>BiPredicate&lt;T,U&gt;</code>。</p>
<p>答案已经明显了，Java8中提供给我们这么多函数式接口就是为了让我们写Lambda表达式更加方便，当然遇到特殊情况，你还是需要定义你自己的函数式接口然后才能写对应的Lambda表达式。</p>
<p>总的来说，如果没有函数式接口，就不能写Lambda表达式。</p>
<h1 id="接口的默认方法与静态方法"><a href="#接口的默认方法与静态方法" class="headerlink" title="接口的默认方法与静态方法"></a>接口的默认方法与静态方法</h1><p>在JDK7中，如果想对接口Collection新增一个方法，那么你需要修改它所有的实现类源码（这是非常恐怖的），在那么Java8之前是怎么设计来解决这个问题的呢，用的是抽象类，比如：</p>
<p>现在有一个接口PersonInterface接口，里面有1个抽象方法:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">PersonInterface</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">getName</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有三个实现类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">YellowPerson</span> <span class="keyword">implements</span> <span class="title">PersonInterface</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;yellow&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WhitePerson</span> <span class="keyword">implements</span> <span class="title">PersonInterface</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;white&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BlackPerson</span> <span class="keyword">implements</span> <span class="title">PersonInterface</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;black&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在我需要在PersonInterface接口中新增一个方法，那么势必它的三个实现类都需要做相应改动才能编译通过，这里我就不进行演示了，那么我们在最开始设计的时候，其实可以增加一个抽象类PersonAbstract，三个实现类改为继承这个抽象类，按照这种设计方法，对PersonInterface接口中新增一个方法是，其实只需要改动PersonAbstract类去实现新增的方法就好了，其他实现类不需要改动了：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">PersonInterface</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">getName</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">walk</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonAbstract</span> <span class="keyword">implements</span> <span class="title">PersonInterface</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">walk</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;walk&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BlackPerson</span> <span class="keyword">extends</span> <span class="title">PersonAbstract</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;black&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WhitePerson</span> <span class="keyword">extends</span> <span class="title">PersonAbstract</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;white&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">YellowPerson</span> <span class="keyword">extends</span> <span class="title">PersonAbstract</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;yellow&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么在Java8中支持直接在接口中添加已经实现了的方法，一种是Default方法（默认方法），一种是Static方法（静态方法）。</p>
<h1 id="接口的默认方法"><a href="#接口的默认方法" class="headerlink" title="接口的默认方法"></a>接口的默认方法</h1><p>在接口中用default修饰的方法称为默认方法 默认方法。<br>接口中的默认方法一定要有默认实现（方法体），接口实现者可以继承它，也可以覆盖它。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">testDefault</span><span class="params">()</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;default&quot;</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="接口的静态方法"><a href="#接口的静态方法" class="headerlink" title="接口的静态方法"></a>接口的静态方法</h1><p>在接口中用static修饰的方法称为静态方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testStatic</span><span class="params">()</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;static&quot;</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>调用方式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">TestInterface.testStatic();</span><br></pre></td></tr></table></figure>
<p>因为有了默认方法和静态方法，所以你不用去修改它的实现类了，可以进行直接调用。</p>
<h1 id="方法的引用"><a href="#方法的引用" class="headerlink" title="方法的引用"></a>方法的引用</h1><p>有个函数式接口Consumer，里面有个抽象方法accept能够接收一个参数但是没有返回值，这个时候我想实现accept方法，让它的功能为打印接收到的那个参数，那么我可以使用Lambda表达式这么做：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Consumer&lt;String&gt; consumer = s -&gt; System.out.println(s);</span><br><span class="line">consumer.accept(<span class="string">&quot;张三&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>但是其实我想要的这个功能PrintStream类（也就是System.out的类型）的println方法已经实现了，这一步还可以再简单点，如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Consumer&lt;String&gt; consumer = System.out::println;</span><br><span class="line">consumer.accept(<span class="string">&quot;张三&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>这就是方法引用，方法引用方法的参数列表必须与函数式接口的抽象方法的参数列表保持一致，返回值不作要求。</p>
<h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><h3 id="引用方法"><a href="#引用方法" class="headerlink" title="引用方法"></a>引用方法</h3><h4 id="实例对象-实例方法名"><a href="#实例对象-实例方法名" class="headerlink" title="实例对象::实例方法名"></a>实例对象::实例方法名</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Consumer&lt;String&gt; consumer = s -&gt; System.out.println(s);</span></span><br><span class="line">Consumer&lt;String&gt; consumer = System.out::println;</span><br><span class="line">consumer.accept(<span class="string">&quot;张三&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>System.out代表的就是PrintStream类型的一个实例，println是这个实例的一个方法。</p>
<h4 id="类名-实例方法名"><a href="#类名-实例方法名" class="headerlink" title="类名::实例方法名"></a>类名::实例方法名</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Function&lt;Long, Long&gt; f = x -&gt; Math.abs(x);</span></span><br><span class="line">Function&lt;Long, Long&gt; f = Math::abs;</span><br><span class="line">Long result = f.apply(-<span class="number">3L</span>);</span><br></pre></td></tr></table></figure>
<p>Math是一个类而abs为该类的静态方法。Function中的唯一抽象方法apply方法参数列表与abs方法的参数列表相同，都是接收一个Long类型参数。</p>
<h4 id="类名-静态方法名"><a href="#类名-静态方法名" class="headerlink" title="类名::静态方法名"></a>类名::静态方法名</h4><p>若Lambda表达式的参数列表的第一个参数，是实例方法的调用者，第二个参数(或无参)是实例方法的参数时，就可以使用这种方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//BiPredicate&lt;String, String&gt; b = (x,y) -&gt; x.equals(y);</span></span><br><span class="line">BiPredicate&lt;String, String&gt; b = String::equals;</span><br><span class="line">b.test(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>String是一个类而equals为该类的定义的实例方法。BiPredicate中的唯一抽象方法test方法参数列表与equals方法<br>的参数列表相同，都是接收两个String类型参数。</p>
<h3 id="引用构造方法"><a href="#引用构造方法" class="headerlink" title="引用构造方法"></a>引用构造方法</h3><p>在引用构造器的时候，构造器参数列表要与接口中抽象方法的参数列表一致,格式为 类名::new。如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Function&lt;Integer, StringBuffer&gt; fun = n -&gt; new StringBuffer(n);</span></span><br><span class="line">Function&lt;Integer, StringBuffer&gt; fun = StringBuffer::<span class="keyword">new</span>;</span><br><span class="line">StringBuffer buffer = fun.apply(<span class="number">10</span>);</span><br></pre></td></tr></table></figure>
<p>Function接口的apply方法接收一个参数，并且有返回值。在这里接收的参数是Integer类型，与StringBuffer类的一个构造方法StringBuffer(int capacity)对应，而返回值就是StringBuffer类型。上面这段代码的功能就是创建一个Function实例，并把它apply方法实现为创建一个指定初始大小的StringBuffer对象。</p>
<h3 id="引用数组"><a href="#引用数组" class="headerlink" title="引用数组"></a>引用数组</h3><p>引用数组和引用构造器很像，格式为 类型[]::new，其中类型可以为基本类型也可以是类。如:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Function&lt;Integer, int[]&gt; fun = n -&gt; new int[n];</span></span><br><span class="line">Function&lt;Integer, <span class="keyword">int</span>[]&gt; fun = <span class="keyword">int</span>[]::<span class="keyword">new</span>;</span><br><span class="line"><span class="keyword">int</span>[] arr = fun.apply(<span class="number">10</span>);</span><br><span class="line">Function&lt;Integer, Integer[]&gt; fun2 = Integer[]::<span class="keyword">new</span>;</span><br><span class="line">Integer[] arr2 = fun2.apply(<span class="number">10</span>);</span><br></pre></td></tr></table></figure>

<h1 id="Optional类"><a href="#Optional类" class="headerlink" title="Optional类"></a>Optional类</h1><p>空指针异常是导致Java应用程序失败的最常见原因，以前，为了解决空指针异常，Google公司著名的Guava项目引入了Optional类，Guava通过使用检查空值的方式来防止代码污染，它鼓励程序员写更干净的代码。受到Google Guava的启发，Optional类已经成为Java 8类库的一部分。</p>
<p>Optional实际上是个容器：它可以保存类型T的值，或者仅仅保存null。Optional提供很多有用的方法，这样我们就不用显式进行空值检测。</p>
<p>创建Optional对象的几个方法：</p>
<ol>
<li>Optional.of(T value)， 返回一个Optional对象，value不能为空，否则会出空指针异常</li>
<li>Optional.ofNullable(T value)， 返回一个Optional对象，value可以为空</li>
<li>Optional.empty()，代表空</li>
</ol>
<p>其他API:</p>
<ol>
<li>optional.isPresent()，是否存在值（不为空）</li>
<li>optional.ifPresent(Consumer&lt;? super T&gt; consumer), 如果存在值则执行consumer</li>
<li>optional.get()，获取value</li>
<li>optional.orElse(T other)，如果没值则返回other</li>
<li>optional.orElseGet(Supplier&lt;? extends T&gt; other)，如果没值则执行other并返回</li>
<li>optional.orElseThrow(Supplier&lt;? extends X&gt; exceptionSupplier)，如果没值则执行exceptionSupplier，并抛出异常</li>
</ol>
<p>那么，我们之前对于防止空指针会这么写：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Order</span> </span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getOrderName</span><span class="params">(Order order)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (order == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> order.name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在用Optional，会改成：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Order</span> </span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getOrderName</span><span class="params">(Order order)</span> </span>&#123;</span><br><span class="line">        Optional&lt;Order&gt; orderOptional = Optional.ofNullable(order);</span><br><span class="line">        <span class="keyword">if</span> (!orderOptional.isPresent()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> orderOptional.get().name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么如果只是改成这样，实质上并没有什么分别，事实上<code>isPresent()</code> 与 <code>obj != null</code> 无任何分别，并且在使用<code>get()</code>之前最好都使用<code>isPresent()</code> ，比如下面的代码在IDEA中会有警告:<code>&#39;Optional.get()&#39; without &#39;isPresent()&#39; check</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createOrder</span><span class="params">(String userName)</span> </span>&#123;</span><br><span class="line">    Optional optional = Optional.ofNullable(userName);</span><br><span class="line">    optional.get();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>另外把 Optional 类型用作属性或是方法参数在<strong>IntelliJ IDEA</strong>中更是强力不推荐的。<br>对于上面的代码我们利用IDEA的提示可以优化成一行：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Order</span> </span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getOrderName</span><span class="params">(Order order )</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Optional.ofNullable(order).map(order1 -&gt; order1.name).orElse(<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个优化过程中map()起了很大作用。</p>
<p>高级API：</p>
<ol>
<li>optional.map(Function&lt;? super T, ? extends U&gt; mapper)，映射，映射规则由function指定，返回映射值的Optional，所以可以继续使用Optional的API。</li>
<li>optional.flatMap(Function&lt;? super T, Optional&lt; U &gt; &gt; mapper)，同map类似，区别在于map中获取的返回值自动被Optional包装，flatMap中返回值保持不变,但入参必须是Optional类型。</li>
<li>optional.filter(Predicate&lt;? super T&gt; predicate)，过滤，按predicate指定的规则进行过滤，不符合规则则返回empty，也可以继续使用Optional的API。</li>
</ol>
<blockquote>
<p>使用 Optional 时尽量不直接调用 <code>Optional.get()</code> 方法, <code>Optional.isPresent()</code> 更应该被视为一个私有方法, 应依赖于其他像 <code>Optional.orElse()</code>, <code>Optional.orElseGet()</code>, <code>Optional.map()</code> 等这样的方法。</p>
</blockquote>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java8</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringCloud组件之eureka（注册中心）</title>
    <url>/2020/10/27/SpringCloud%E7%BB%84%E4%BB%B6%E4%B9%8Beureka%EF%BC%88%E6%90%AD%E5%BB%BA%E3%80%81%E9%9B%86%E7%BE%A4%E3%80%81%E5%BF%83%E8%B7%B3%EF%BC%89/</url>
    <content><![CDATA[<h1 id="eureka"><a href="#eureka" class="headerlink" title="eureka"></a>eureka</h1><h2 id="eureka是什么？"><a href="#eureka是什么？" class="headerlink" title="eureka是什么？"></a>eureka是什么？</h2><p>eureka是Netflix的子模块之一，也是一个核心的模块，eureka里有2个组件，一个是EurekaServer(一个独立的项目) 这个是用于定位服务以实现中间层服务器的负载平衡和故障转移，另一个便是EurekaClient（我们的微服务）它是用于与Server交互的，可以使得交互变得非常简单：只需要通过服务标识符即可拿到服务。</p>
<h2 id="与spring-cloud的关系"><a href="#与spring-cloud的关系" class="headerlink" title="与spring-cloud的关系"></a>与spring-cloud的关系</h2><p>Spring Cloud 封装了 Netflix 公司开发的 Eureka 模块来实现服务注册和发现(可以对比Zookeeper)。<br>Eureka 采用了 C-S 的设计架构。Eureka Server 作为服务注册功能的服务器，它是服务注册中心。<br>而系统中的其他微服务，使用 Eureka 的客户端连接到 Eureka Server并维持心跳连接。这样系统的维护人员就可以通过 Eureka Server 来监控系统中各个微服务是否正常运行。SpringCloud 的一些其他模块（比如Zuul）就可以通过 Eureka Server 来发现系统中的其他微服务，并执行相关的逻辑。</p>
<h2 id="eureka角色关系"><a href="#eureka角色关系" class="headerlink" title="eureka角色关系"></a>eureka角色关系</h2><p><img data-src="https://i.loli.net/2020/10/27/fTMlspmcJDznq9i.png" alt="eureka角色关系.png"></p>
<h2 id="如何使用？"><a href="#如何使用？" class="headerlink" title="如何使用？"></a>如何使用？</h2><p>在spring-cloud项目里面加入依赖：<br>eureka客户端：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>eureka服务端：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p> eureka服务端项目里面加入以下配置：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">3000</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">server:</span></span><br><span class="line">    <span class="attr">enable-self-preservation:</span> <span class="literal">false</span>  <span class="comment">#关闭自我保护机制</span></span><br><span class="line">    <span class="attr">eviction-interval-timer-in-ms:</span> <span class="number">4000</span> <span class="comment">#设置清理间隔（单位：毫秒 默认是60*1000）</span></span><br><span class="line">  <span class="attr">instance:</span></span><br><span class="line">    <span class="attr">hostname:</span> <span class="string">localhost</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">registerWithEureka:</span> <span class="literal">false</span> <span class="comment">#不把自己作为一个客户端注册到自己身上</span></span><br><span class="line">    <span class="attr">fetchRegistry:</span> <span class="literal">false</span>  <span class="comment">#不需要从服务端获取注册信息（因为在这里自己就是服务端，而且已经禁用自己注册了）</span></span><br><span class="line">    <span class="attr">serviceUrl:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://$&#123;eureka.instance.hostname&#125;:$&#123;server.port&#125;/eureka</span></span><br></pre></td></tr></table></figure>
<p> 当然，不是全部必要的，这里只是把我这里的配置copy过来了<br> 然后在spring-boot启动项目上 加入注解<code>@EnableEurekaServer</code>就可以启动项目了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableEurekaServer</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppEureka</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(AppEureka.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果看见这个图片，那么说明你就搭建好了:<br><img data-src="https://i.loli.net/2020/10/27/bax5Pjp9zkF8fJn.png" alt="eureka首页.png"></p>
<p><em>注：图片中警告只是说你把他的自我保护机制关闭了</em></p>
<p>eureka客户端配置:</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">6000</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">serviceUrl:</span></span><br><span class="line">        <span class="attr">defaultZone:</span> <span class="string">http://localhost:3000/eureka/</span>  <span class="comment">#eureka服务端提供的注册地址 参考服务端配置的这个路径</span></span><br><span class="line">  <span class="attr">instance:</span></span><br><span class="line">    <span class="attr">instance-id:</span> <span class="string">power-1</span> <span class="comment">#此实例注册到eureka服务端的唯一的实例ID </span></span><br><span class="line">    <span class="attr">prefer-ip-address:</span> <span class="literal">true</span> <span class="comment">#是否显示IP地址</span></span><br><span class="line">    <span class="attr">leaseRenewalIntervalInSeconds:</span> <span class="number">10</span> <span class="comment">#eureka客户需要多长时间发送心跳给eureka服务器，表明它仍然活着，默认为30秒 (与下面配置的单位都是秒)</span></span><br><span class="line">    <span class="attr">leaseExpirationDurationInSeconds:</span> <span class="number">30</span> <span class="comment">#Eureka服务器在接收到实例的最后一次发出的心跳后，需要等待多久才可以将此实例删除，默认为90秒</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">server-power</span> <span class="comment">#此实例注册到eureka服务端的name </span></span><br></pre></td></tr></table></figure>
<p>然后在客户端的spring-boot启动项目上加入注解<code>@EnableEurekaClient</code>就可以启动项目了，这里就不截图了我们直接来看效果图：<br><img data-src="https://i.loli.net/2020/10/27/bax5Pjp9zkF8fJn.png" alt="eureka首页.png"></p>
<p>这里我们能看见 名字叫<em>server-power</em>的（图中将其大写了）,id为<em>power-1</em>的服务注册到我们的Eureka上面来了 至此，一个简单的eureka已经搭建好了。</p>
<h1 id="eureka集群"><a href="#eureka集群" class="headerlink" title="eureka集群"></a>eureka集群</h1><h2 id="eureka集群原理"><a href="#eureka集群原理" class="headerlink" title="eureka集群原理"></a>eureka集群原理</h2><p>服务启动后向Eureka注册，Eureka Server会将注册信息向其他Eureka Server进行同步，当服务消费者要调用服务提供者，则向服务注册中心获取服务提供者地址，然后会将服务提供者地址缓存在本地，下次再调用时，则直接从本地缓存中取，完成一次调用。</p>
<h2 id="eureka集群配置"><a href="#eureka集群配置" class="headerlink" title="eureka集群配置"></a>eureka集群配置</h2><p>刚刚我们了解到 Eureka Server会将注册信息向其他Eureka Server进行同步，那么我们得声明有哪些server呢？<br>这里假设我们有3个Eureka Server如图：<br><img data-src="https://i.loli.net/2020/10/27/euiSHPbv9tFpJCs.png" alt="eurekaserver.png"></p>
<p>现在怎么声明集群环境的server呢？ 我们看一张图：<br><img data-src="https://i.loli.net/2020/10/27/mMVUvdhpsw3tkfW.png" alt="eureka角色关系.png"></p>
<p>可能看着有点抽象，我们来看看具体配置</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">3000</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">server:</span></span><br><span class="line">    <span class="attr">enable-self-preservation:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">eviction-interval-timer-in-ms:</span> <span class="number">4000</span></span><br><span class="line">  <span class="attr">instance:</span></span><br><span class="line">    <span class="attr">hostname:</span> <span class="string">eureka3000.com</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">registerWithEureka:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">fetchRegistry:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">serviceUrl:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://eureka3001.com:3001/eureka,http://eureka3002.com:3002/eureka</span></span><br></pre></td></tr></table></figure>
<p>这里 方便理解集群 我们做了一个域名的映射(条件不是特别支持我使用三台笔记本来测试。。。) 至于域名怎么映射的话 这里简单提一下吧 修改你的hosts文件（win10的目录在C:\Windows\System32\drivers\etc 其他系统的话自行百度一下把）附上我的hosts文件：</p>
<figure class="highlight accesslog"><table><tr><td class="code"><pre><span class="line"><span class="number">127.0.0.1</span>  eureka3000.com</span><br><span class="line"><span class="number">127.0.0.1</span>  eureka3001.com</span><br><span class="line"><span class="number">127.0.0.1</span>  eureka3002.com</span><br></pre></td></tr></table></figure>
<p>我们回到主题，我们发现，集群配置与单体不同的点在于，单体是把服务注册到自己身上，而集群是注册到其它服务身上<br>至于为什么不注册自己了呢？回到最上面我们说过，eureka的server会把自己的注册信息与其他的server同步，所以这里我们不需要注册到自己身上，因为另外两台服务器会配置本台服务器。(这里可能有点绕，可以参考一下刚刚那张集群环境的图，或者自己动手配置一下，另外两台eureka的配置与这个是差不多的，就不发出来了，只要注意是注册到其他的服务上面就好了)<br>当三台eureka配置好之后，全部启动一下就可以看见效果了:<br><img data-src="https://i.loli.net/2020/10/27/N2vOhdqYSFA3MH7.png" alt="eureka集群注册.png"></p>
<p>当然，我们这里仅仅是把服务端配置好了， 那客户端怎么配置呢？ 话不多说，上代码：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">client:</span></span><br><span class="line">  <span class="attr">serviceUrl:</span></span><br><span class="line">    <span class="attr">defaultZone:</span> <span class="string">http://localhost:3000/eureka/,http://eureka3001.com:3001/eureka,http://eureka3002.com:3002/eureka</span></span><br></pre></td></tr></table></figure>

<p>我们这里只截取了要改动的那一部分。就是原来是注册到那一个地址上面，现在是要写三个eureka注册地址，但是不是代表他会注册三次，因为我们eureka server的注册信息是同步的，这里只需要注册一次就可以了，但是为什么要写三个地址呢。因为这样就可以做到高可用的配置：打个比方有3台服务器。但是突然宕机了一台，但是其他2台还健在，依然可以注册我们的服务，换句话来讲，只要有一台服务还建在，那么就可以注册服务。<br>这里效果图就不发了，和之前单机的没什么两样，只是你服务随便注册到哪个eureka server上其他的eureka server上都有该服务的注册信息。</p>
<h1 id="CAP定理的含义"><a href="#CAP定理的含义" class="headerlink" title="CAP定理的含义"></a>CAP定理的含义</h1><p>分布式系统（distributed system）正变得越来越重要，大型网站几乎都是分布式的。</p>
<p>分布式系统的最大难点，就是各个节点的状态如何同步。CAP定理是这方面的基本定理，也是理解分布式系统的起点。</p>
<h2 id="分布式系统的三个指标"><a href="#分布式系统的三个指标" class="headerlink" title="分布式系统的三个指标"></a>分布式系统的三个指标</h2><p><img data-src="https://www.wangbase.com/blogimg/asset/201807/bg2018071607.jpg"></p>
<p>1998年，加州大学的计算机科学家<em>Eric Brewer</em>提出，分布式系统有三个指标。</p>
<ul>
<li>Consistency</li>
<li>Availability</li>
<li>Partition tolerance</li>
</ul>
<p>它们的第一个字母分别是 C、A、P。</p>
<p><em>Eric Brewer</em>说，这三个指标不可能同时做到。这个结论就叫做 CAP 定理。</p>
<h2 id="Partition-tolerance（分区容错）"><a href="#Partition-tolerance（分区容错）" class="headerlink" title="Partition tolerance（分区容错）"></a>Partition tolerance（分区容错）</h2><p>先看 Partition tolerance，中文叫做”分区容错”。</p>
<p>大多数分布式系统都分布在多个子网络。每个子网络就叫做一个区（partition）。分区容错的意思是，区间通信可能失败。比如，一台服务器放在中国，另一台服务器放在美国，这就是两个区，它们之间可能无法通信。</p>
<p><img data-src="https://www.wangbase.com/blogimg/asset/201807/bg2018071601.png"></p>
<p>上图中，G1 和 G2 是两台跨区的服务器。G1 向 G2 发送一条消息，G2 可能无法收到。系统设计的时候，必须考虑到这种情况。</p>
<p>一般来说，分区容错无法避免，因此可以认为CAP的P总是成立。CAP定理告诉我们，剩下的C和A无法同时做到。</p>
<h2 id="Consistency（一致性）"><a href="#Consistency（一致性）" class="headerlink" title="Consistency（一致性）"></a>Consistency（一致性）</h2><p>Consistency 中文叫做”一致性”。意思是，写操作之后的读操作，必须返回该值。举例来说，某条记录是 v0，用户向 G1 发起一个写操作，将其改为 v1。<br><img data-src="https://www.wangbase.com/blogimg/asset/201807/bg2018071602.png"></p>
<p>接下来，用户的读操作就会得到 v1。这就叫一致性。<br><img data-src="https://www.wangbase.com/blogimg/asset/201807/bg2018071603.png"><br>问题是，用户有可能向 G2 发起读操作，由于 G2 的值没有发生变化，因此返回的是 v0。G1 和 G2 读操作的结果不一致，这就不满足一致性了。<br><img data-src="https://www.wangbase.com/blogimg/asset/201807/bg2018071604.png"><br>为了让 G2 也能变为 v1，就要在 G1 写操作的时候，让 G1 向 G2 发送一条消息，要求 G2 也改成 v1。<br><img data-src="https://www.wangbase.com/blogimg/asset/201807/bg2018071605.png"><br>这样的话，用户向 G2 发起读操作，也能得到 v1。<br><img data-src="https://www.wangbase.com/blogimg/asset/201807/bg2018071606.png">  </p>
<h2 id="Availability（可用性）"><a href="#Availability（可用性）" class="headerlink" title="Availability（可用性）"></a>Availability（可用性）</h2><p>Availability 中文叫做”可用性”，意思是只要收到用户的请求，服务器就必须给出回应。</p>
<p>用户可以选择向 G1 或 G2 发起读操作。不管是哪台服务器，只要收到请求，就必须告诉用户，到底是 v0 还是 v1，否则就不满足可用性。</p>
<h2 id="Consistency-和-Availability-的矛盾"><a href="#Consistency-和-Availability-的矛盾" class="headerlink" title="Consistency 和 Availability 的矛盾"></a>Consistency 和 Availability 的矛盾</h2><p>一致性和可用性，为什么不可能同时成立？答案很简单，因为可能通信失败（即出现分区容错）。</p>
<p>如果保证 G2 的一致性，那么 G1 必须在写操作时，锁定 G2 的读操作和写操作。只有数据同步后，才能重新开放读写。锁定期间，G2 不能读写，没有可用性不。</p>
<p>如果保证 G2 的可用性，那么势必不能锁定 G2，所以一致性不成立。</p>
<p>综上所述，G2 无法同时做到一致性和可用性。系统设计时只能选择一个目标。如果追求一致性，那么无法保证所有节点的可用性；如果追求所有节点的可用性，那就没法做到一致性。</p>
<h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p>在什么场合，可用性高于一致性？</p>
<p>举例来说，发布一张网页到 CDN，多个服务器有这张网页的副本。后来发现一个错误，需要更新网页，这时只能每个服务器都更新一遍。</p>
<p>一般来说，网页的更新不是特别强调一致性。短时期内，一些用户拿到老版本，另一些用户拿到新版本，问题不会特别大。当然，所有人最终都会看到新版本。所以，这个场合就是可用性高于一致性。</p>
<h1 id="eureka对比Zookeeper"><a href="#eureka对比Zookeeper" class="headerlink" title="eureka对比Zookeeper"></a>eureka对比Zookeeper</h1><p>Zookeeper在设计的时候遵循的是CP原则，即一致性,Zookeeper会出现这样一种情况，当master节点因为网络故障与其他节点失去联系时剩余节点会重新进行leader选举，问题在于，选举leader的时间太长：30~120s，且选举期间整个Zookeeper集群是不可用的，这就导致在选举期间注册服务处于瘫痪状态，在云部署的环境下，因网络环境使Zookeeper集群失去master节点是较大概率发生的事情，虽然服务能够最终恢复，但是漫长的选举时间导致长期的服务注册不可用是不能容忍的。<br>Eureka在设计的时候遵循的是AP原则，即可用性。Eureka各个节点（服务)是平等的， 没有主从之分，几个节点down掉不会影响正常工作，剩余的节点（服务） 依然可以提供注册与查询服务，而Eureka的客户端在向某个Eureka注册或发现连接失败，则会自动切换到其他节点，也就是说，只要有一台Eureka还在，就能注册可用（保证可用性）， 只不过查询到的信息不是最新的（不保证强一致），除此之外，Eureka还有自我保护机制，如果在15分钟内超过85%节点都没有正常心跳，那么eureka就认为客户端与注册中心出现了网络故障，此时会出现一下情况：  </p>
<ol>
<li>Eureka不再从注册列表中移除因为长时间没有收到心跳而过期的服务</li>
<li>Eureka仍然能够接收新服务的注册和查询请求，但是不会被同步到其它节点上（即保证当前节点可用）</li>
<li>当网络稳定后，当前实例新的注册信息会被同步到其它节点中</li>
</ol>
]]></content>
      <categories>
        <category>Spring微服务</category>
      </categories>
      <tags>
        <tag>SpringCloud</tag>
        <tag>Eureka</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot2.X快速构建和配置</title>
    <url>/2020/11/03/SpringBoot2-X%E5%BF%AB%E9%80%9F%E6%9E%84%E5%BB%BA%E5%92%8C%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<h1 id="SpringBoot是什么？"><a href="#SpringBoot是什么？" class="headerlink" title="SpringBoot是什么？"></a>SpringBoot是什么？</h1><p><img data-src="https://img-blog.csdnimg.cn/20181117220632243.png"><br>Spring Boot 是由 Pivotal 团队提供的全新框架。<br>Spring Boot 是所有基于 Spring Framework 5.0 开发的项目的起点。<br>Spring Boot 的设计是为了让你尽可能快的跑起来 Spring 应用程序并且尽可能减少你的配置文件。</p>
<p>从最根本上来讲，Spring Boot 就是一些库的集合，它能够被任意项目的构建系统所使用。它使用<em>习惯优于配置</em>（项目中存在大量的配置，此外还内置一个习惯性的配置）的理念让你的项目快速运行起来。用大佬的话来理解，就是 spring boot 其实不是什么新的框架，它默认配置了很多框架的使用方式，就像 maven 整合了所有的 jar 包，spring boot 整合了所有的框架，总结一下及几点：</p>
<ol>
<li>为所有 Spring 开发提供一个更快更广泛的入门体验。</li>
<li>零配置。无冗余代码生成和XML 强制配置，遵循<em>约定大于配置</em> 。</li>
<li>集成了大量常用的第三方库的配置， Spring Boot 应用为这些第三方库提供了几乎可以零配置的开箱即用的能力。</li>
<li>提供一系列大型项目常用的非功能性特征，如嵌入式服务器、安全性、度量、运行状况检查、外部化配置等。</li>
<li>Spring Boot 不是Spring 的替代者，Spring 框架是通过 IOC 机制来管理 Bean 的。Spring Boot 依赖 Spring 框架来管理对象的依赖。Spring Boot 并不是Spring 的精简版本，而是为使用 Spring 做好各种产品级准备</li>
</ol>
<h1 id="Spring-Boot-在应用中的角色"><a href="#Spring-Boot-在应用中的角色" class="headerlink" title="Spring Boot 在应用中的角色"></a>Spring Boot 在应用中的角色</h1><p>Spring Boot 是基于 Spring Framework 来构建的，Spring Framework 是一种 J2EE 的框架<br>Spring Boot 是一种快速构建 Spring 应用<br>Spring Cloud 是构建 Spring Boot 分布式环境，也就是常说的云应用<br>Spring Boot 中流砥柱，承上启下</p>
<h1 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h1><ol>
<li>JDK8以上。</li>
<li>建议安装Intellj Idea Ultimate（旗舰版）。</li>
<li>具备Maven和SpringMVC技术。</li>
</ol>
<h1 id="SpringBoot开发要求"><a href="#SpringBoot开发要求" class="headerlink" title="SpringBoot开发要求"></a>SpringBoot开发要求</h1><ol>
<li>创建Maven工程，构建项目结构。</li>
<li>配置pom.xml，引用各种starter启动器简化配置。</li>
<li>配置运行参数。</li>
<li>编码与测试。</li>
<li>打包与独立运行。</li>
</ol>
<h1 id="SpringBoot的目录结构"><a href="#SpringBoot的目录结构" class="headerlink" title="SpringBoot的目录结构"></a>SpringBoot的目录结构</h1><table>
<thead>
<tr>
<th>目录</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>/src/main</td>
<td>项目根目录</td>
</tr>
<tr>
<td>/java</td>
<td>Java源代码目录</td>
</tr>
<tr>
<td>/resources</td>
<td>资源目录</td>
</tr>
<tr>
<td>/resources/static</td>
<td>静态资源目录</td>
</tr>
<tr>
<td>/resources/templates</td>
<td>表示层页面目录</td>
</tr>
<tr>
<td>/resources/application.properties</td>
<td>静态资源目录</td>
</tr>
<tr>
<td>/test</td>
<td>测试文件目录</td>
</tr>
</tbody></table>
<h1 id="基本启动器"><a href="#基本启动器" class="headerlink" title="基本启动器"></a>基本启动器</h1><table>
<thead>
<tr>
<th>启动器</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>spring-boot-starter-parent</td>
<td>所有Spring Boot组件的基础引用</td>
</tr>
<tr>
<td>spring-boot-starter-web</td>
<td>提供web的支持</td>
</tr>
<tr>
<td>spring-boot-starter-thymeleaf</td>
<td>提供thymeleaf模板引擎的支持</td>
</tr>
<tr>
<td>spring-boot-maven-plugin</td>
<td>提供打包的支持</td>
</tr>
</tbody></table>
<h1 id="SpringBoot常用配置"><a href="#SpringBoot常用配置" class="headerlink" title="SpringBoot常用配置"></a>SpringBoot常用配置</h1><table>
<thead>
<tr>
<th>web常用配置</th>
<th>默认值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>debug</td>
<td>false</td>
<td>开启/关闭调试模式</td>
</tr>
<tr>
<td>server.port</td>
<td>8080</td>
<td>服务器脚本</td>
</tr>
<tr>
<td>server.servlet.context-path</td>
<td>/</td>
<td>应用上下文</td>
</tr>
<tr>
<td>spring.http.encoding.charset</td>
<td>utf-8</td>
<td>默认字符集编码</td>
</tr>
<tr>
<td>spring.thymeleaf.cache</td>
<td>true</td>
<td>开启/关闭页面缓存</td>
</tr>
<tr>
<td>spring.mvc.date-format</td>
<td></td>
<td>日期输入格式</td>
</tr>
<tr>
<td>spring.jackson.date-format</td>
<td></td>
<td>json输出的日期格式</td>
</tr>
<tr>
<td>spring.jackson.time-zone</td>
<td></td>
<td>设置GMT时区</td>
</tr>
</tbody></table>
<h1 id="日志配置"><a href="#日志配置" class="headerlink" title="日志配置"></a>日志配置</h1>]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
</search>
